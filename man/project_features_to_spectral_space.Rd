% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/projection_helpers.R
\name{project_features_to_spectral_space}
\alias{project_features_to_spectral_space}
\title{Project Features onto a Spectral Basis}
\usage{
project_features_to_spectral_space(
  feature_matrix,
  U_basis,
  tol_orthonormal = sqrt(.Machine$double.eps),
  assume_orthonormal = FALSE
)
}
\arguments{
\item{feature_matrix}{A numeric matrix representing features. It can be in
`V_p x C` format (parcels x features/conditions) or `C x V_p` format.
The function will attempt to orient it correctly based on `U_basis`.
Sparse `Matrix` inputs are handled with sparse-aware linear algebra and only
small intermediate matrices are densified. Very large sparse inputs
(`prod(dim(.)) > 1e7`) result in an error.}

\item{U_basis}{A numeric matrix representing the spectral basis, typically with
dimensions `V_p x k_dims_basis` (parcels x basis dimensions).
Sparse `U_basis` inputs are handled similarly and extremely large sparse bases
trigger an error to avoid densification.}

\item{tol_orthonormal}{A numeric tolerance to check for orthonormality of `U_basis`.
`max(abs(crossprod(U_basis) - I)) / k_dims_basis` is compared against this tolerance.
Default is `sqrt(.Machine$double.eps)`.}

\item{assume_orthonormal}{Logical. If `TRUE`, `U_basis` is assumed to be orthonormal,
and the check (including rank check and `UtU` calculation) is skipped, 
directly using the faster projection `crossprod(U_basis, features)`.
Default is `FALSE`.}
}
\value{
A numeric (dense) matrix containing the projected features.
  If `feature_matrix` was oriented to `V_p x C` (parcels x features/conditions),
  the output will be `k_dims_basis x C` (basis dimensions x features/conditions).
  If `feature_matrix` was `C x V_p` and was transposed for projection, the output
  will be `C x k_dims_basis` to maintain the original feature orientation as rows.
}
\description{
Projects a feature matrix onto a given spectral basis. Handles potential
  transposition of the feature matrix and uses the appropriate orthogonal projection
  formula based on whether the basis is orthonormal. Sparse inputs are processed
  with \code{Matrix} methods and the result is returned as a dense matrix.
}
\examples{
V_p <- 10
k_dims <- 3
C <- 5
U_basis_ortho <- svd(matrix(rnorm(V_p * k_dims), V_p, k_dims))$u
U_basis_non_ortho <- matrix(rnorm(V_p * k_dims), V_p, k_dims)

# Feature matrix: V_p x C (parcels x conditions)
features1 <- matrix(rnorm(V_p * C), V_p, C)
proj1_ortho <- project_features_to_spectral_space(features1, U_basis_ortho)
print(dim(proj1_ortho))
proj1_non_ortho <- project_features_to_spectral_space(features1, U_basis_non_ortho)
print(dim(proj1_non_ortho))

# Sparse input example
features_sp <- Matrix::rsparsematrix(V_p, C, 0.2)
proj_sp <- project_features_to_spectral_space(features_sp, U_basis_ortho)
print(class(proj_sp))

# Ambiguous square matrix error
V_p_sq <- 7
U_basis_sq <- matrix(rnorm(V_p_sq*k_dims), V_p_sq, k_dims)
features_sq_ambiguous <- matrix(rnorm(V_p_sq*V_p_sq), V_p_sq, V_p_sq)
try(project_features_to_spectral_space(features_sq_ambiguous, U_basis_sq))

# Rank deficient U_basis warning
U_rank_def <- matrix(rnorm(V_p * k_dims), V_p, k_dims)
if (k_dims > 1) U_rank_def[, k_dims] <- U_rank_def[, 1] # Make last col same as first
try(project_features_to_spectral_space(features1, U_rank_def))

}
