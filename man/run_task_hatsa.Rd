% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task_hatsa_main.R
\name{run_task_hatsa}
\alias{run_task_hatsa}
\title{Run Task-Informed HATSA (task_hatsa)}
\usage{
run_task_hatsa(
  subject_data_list,
  anchor_indices,
  spectral_rank_k,
  task_data_list = NULL,
  task_method = c("lambda_blend", "gev_patch", "core_hatsa"),
  lambda_blend_value = 0.15,
  k_gev_dims = 10,
  row_augmentation = TRUE,
  residualize_condition_anchors = FALSE,
  omega_weights = NULL,
  omega_mode = c("fixed", "adaptive"),
  reliability_scores_list = NULL,
  scale_omega_trace = TRUE,
  alpha_laplacian = 0.93,
  degree_type_laplacian = c("abs", "positive", "signed"),
  k_conn_pos = 10,
  k_conn_neg = 10,
  k_conn_task_pos = 10,
  k_conn_task_neg = 10,
  similarity_method_task = "pearson",
  W_task_helper_func = NULL,
  n_refine = 5,
  check_redundancy = TRUE,
  redundancy_threshold = 0.45,
  residualize_k_conn_proj = 64,
  residualize_k_conn_labels = 10,
  gev_lambda_max = 0.8,
  gev_epsilon_reg = 1e-06,
  parcel_names = NULL,
  verbose = TRUE
)
}
\arguments{
\item{subject_data_list}{List where each element is a numeric matrix (`T_i x V_p`)
of time-series data for one subject.}

\item{anchor_indices}{Integer vector, indices of the canonical anchor parcels (`1` to `V_p`).}

\item{spectral_rank_k}{Integer, the desired dimensionality of the primary spectral sketch.}

\item{task_data_list}{List (parallel to `subject_data_list`). Each element provides
task-related data for a subject. Structure depends on `task_method` and subsequent
processing (e.g., a `C x V_p` matrix of activations/betas for `compute_W_task_from_activations`
or anchor augmentation). Required if `task_method != "core_hatsa"` or `row_augmentation=TRUE`.
Assumed cross-validated if necessary before input.}

\item{task_method}{Character string: `"core_hatsa"`, `"lambda_blend"`, or `"gev_patch"`. Default: `"lambda_blend"`.}

\item{lambda_blend_value}{Numeric `lambda` in `[0,1]`. Weight for `L_task` in blend. Default 0.15.}

\item{k_gev_dims}{Integer, requested dimension for GEV patches. Default 10. Used if `task_method == "gev_patch"`.}

\item{row_augmentation}{Logical. If `TRUE`, add projected task features to anchor matrices
for GPA refinement. Requires suitable `task_data_list`. Default `TRUE` if suitable data provided.}

\item{residualize_condition_anchors}{Logical. If `TRUE` and `row_augmentation` is `TRUE`,
residualize projected task anchors against parcel anchors. Default `FALSE`.}

\item{omega_weights}{List specifying fixed weights for weighted Procrustes (e.g.,
`list(parcel = 1.0, condition = 0.5)`). Used if `row_augmentation=TRUE` and `omega_mode == "fixed"`.
Defaults handled by `solve_procrustes_rotation_weighted`.}

\item{omega_mode}{Character string: `"fixed"` or `"adaptive"`. Controls weighting in GPA. Default `"fixed"`.}

\item{reliability_scores_list}{Either \code{NULL} or a list with one entry per subject.
Each entry should be a numeric vector of reliability scores for task data (length \code{C}) or \code{NULL}.
Elements with differing lengths trigger warnings. Used when \code{omega_mode == "adaptive"}.}

\item{scale_omega_trace}{Logical. Whether to rescale weights in weighted GPA so trace equals total anchors. Default `TRUE`.}

\item{alpha_laplacian}{Numeric, laziness parameter for graph Laplacians (`L = I - alpha D^{-1} W`). Default 0.93.}

\item{degree_type_laplacian}{Character string (`"abs"`, `"positive"`, `"signed"`). Type of degree calculation for Laplacian. Default `"abs"`.}

\item{k_conn_pos}{Integer >= 0. k-NN sparsification for positive edges in `W_conn`.}

\item{k_conn_neg}{Integer >= 0. k-NN sparsification for negative edges in `W_conn`.}

\item{k_conn_task_pos}{Integer >= 0. k-NN sparsification for positive edges in `W_task`.}

\item{k_conn_task_neg}{Integer >= 0. k-NN sparsification for negative edges in `W_task`.}

\item{similarity_method_task}{Character string or function. Method to compute similarity for `W_task`
(e.g., "pearson", "spearman"). Default "pearson".}

\item{W_task_helper_func}{Function. The specific function to compute `W_task` (e.g.,
`compute_W_task_from_activations`, `compute_W_task_from_encoding`). If `NULL`, attempts
to infer based on `task_data_list` structure (currently assumes activations `C x Vp`). Default `NULL`.}

\item{n_refine}{Integer >= 0. Number of GPA refinement iterations.}

\item{check_redundancy}{Logical. If `TRUE`, check correlation between `W_conn` and `W_task`. Default `TRUE`.}

\item{redundancy_threshold}{Numeric. Spearman rho threshold for triggering `W_task` residualization. Default 0.45.}

\item{residualize_k_conn_proj}{Integer. Number of `L_conn` eigenvectors to project `W_task` out of. Default 64.}

\item{residualize_k_conn_labels}{Integer. k-NN value for re-sparsifying `W_task_res` after residualization. Default 10.}

\item{gev_lambda_max}{Numeric. Max GEV eigenvalue `lambda` to retain for patches. Default 0.8.}

\item{gev_epsilon_reg}{Numeric. Small regularization for `L_conn` in GEV. Default 1e-6.}

\item{parcel_names}{Optional character vector of parcel names. If `NULL`, names like "P1", "P2"... are generated.}

\item{verbose}{Logical. Print progress messages? Default `TRUE`.}
}
\value{
A list representing the `task_hatsa_projector` object (structure TBD, needs final class definition).
        Contains aligned bases, rotations, parameters, QC metrics, etc.
}
\description{
Performs Hyperalignment via Task-Informed Shared Analysis (task_hatsa) on a list of subject data,
incorporating task information during basis shaping and/or alignment refinement.
}
