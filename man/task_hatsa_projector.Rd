% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task_hatsa_projector.R
\name{task_hatsa_projector}
\alias{task_hatsa_projector}
\title{Task-HATSA Projector Object}
\usage{
task_hatsa_projector(task_hatsa_results)
}
\arguments{
\item{task_hatsa_results}{A list containing the outputs from the `task_hatsa` run.
This list is expected to have specific named elements corresponding to various
stages and parameters of the analysis (e.g., `parameters`, `R_final_list`,
`U_original_list`, `Lambda_original_list`, `T_anchor_final`, `U_aligned_list`,
`qc_metrics`, `anchor_augmentation_info`, `gev_patch_data`).}
}
\value{
A `task_hatsa_projector` object.

An object of class `c("task_hatsa_projector", "hatsa_projector", "multiblock_biprojector", "projector", "list")`.
}
\description{
An S3 object of class `task_hatsa_projector` that stores the results of a
Task-Informed Harmonized Tensors SVD Alignment (task_hatsa) analysis.
This object inherits from `hatsa_projector`.

Creates a `task_hatsa_projector` object. It takes the full results list from
the main `task_hatsa` computation (as prepared by `construct_output` helper)
and structures it into an S3 object, inheriting from `hatsa_projector`.
}
\section{Fields}{

\describe{
\item{\code{qc_metrics}}{A list per subject containing QC metrics like `rho_redundancy`
(correlation between W_conn and W_task_raw) and `was_residualized` (boolean flag).}

\item{\code{anchor_augmentation_info}}{A list containing information related to anchor augmentation,
such as `m_parcel_rows`, `m_task_rows_effective`, `condition_labels`,
`was_residualized` (for condition anchors), `omega_mode_used`, `omega_weights_params`,
and `trace_scaled`.}

\item{\code{gev_patch_data}}{A list containing GEV-specific outputs if `task_method == "gev_patch"`.
Includes `U_patch_list`, `Lambda_patch_list`, `R_patch_list`, and `diagnostics`.
NULL otherwise.}
}}

\examples{
# This is a conceptual example, as real data structures are complex.
# Assuming hatsa_results and params are populated from run_hatsa_core:
# projector_obj <- hatsa_projector(
#   hatsa_core_results = list(
#     U_aligned_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE),
#     R_final_list = replicate(5, diag(10), simplify=FALSE),
#     U_original_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE),
#     Lambda_original_list = replicate(5, runif(10, 0.1, 1), simplify=FALSE), # example
#     Lambda_original_gaps_list = replicate(5, runif(9, 0.05, 0.5), simplify=FALSE), # example
#     T_anchor_final = matrix(rnorm(5*10), 5, 10)
#   ),
#   parameters = list(
#     k=10,
#     N_subjects=5,
#     V_p=100,
#     method="hatsa_core"
#   )
# )
# class(projector_obj)
# names(projector_obj)
}
\seealso{
`run_task_hatsa`, `hatsa_projector`
}
