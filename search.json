[{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":null,"dir":"","previous_headings":"","what":"GitHub Actions CI/CD for HATSA","title":"GitHub Actions CI/CD for HATSA","text":"directory contains GitHub Actions workflows continuous integration deployment HATSA R package.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"id_1-r-cmd-checkyaml","dir":"","previous_headings":"Workflows","what":"1. R-CMD-check.yaml","title":"GitHub Actions CI/CD for HATSA","text":"Purpose: Comprehensive R package checking across multiple platforms - Triggers: Push/PR main/master branches - Platforms: Ubuntu (devel, release, oldrel-1), Windows (release), macOS (release) - Actions: - Install R dependencies - Run R CMD check - Upload test snapshots","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"id_2-test-coverageyaml","dir":"","previous_headings":"Workflows","what":"2. test-coverage.yaml","title":"GitHub Actions CI/CD for HATSA","text":"Purpose: Code coverage measurement reporting - Triggers: Push/PR main/master branches - Platform: Ubuntu latest - Actions: - Run covr::package_coverage() - Generate Cobertura XML report - Upload Codecov","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"id_3-pkgdownyaml","dir":"","previous_headings":"Workflows","what":"3. pkgdown.yaml","title":"GitHub Actions CI/CD for HATSA","text":"Purpose: Build deploy package documentation website - Triggers: Push main/master, PRs, releases, manual dispatch - Platform: Ubuntu latest - Actions: - Build pkgdown site - Deploy GitHub Pages (push main )","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"id_4-styleyaml","dir":"","previous_headings":"Workflows","what":"4. style.yaml","title":"GitHub Actions CI/CD for HATSA","text":"Purpose: Automated code styling styler - Triggers: Push/PR main/master branches - Platform: Ubuntu latest - Actions: - Run styler::style_pkg() - Commit push style changes (push )","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"for-repository-owner","dir":"","previous_headings":"Setup Requirements","what":"For Repository Owner","title":"GitHub Actions CI/CD for HATSA","text":"Enable GitHub Pages: Go Settings > Pages > Source: GitHub Actions Codecov Token (optional): Add CODECOV_TOKEN secret private repos Branch Protection: Consider requiring status checks pass merging","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"for-contributors","dir":"","previous_headings":"Setup Requirements","what":"For Contributors","title":"GitHub Actions CI/CD for HATSA","text":"additional setup required workflows run automatically PRs Style changes applied push events (PRs)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"configuration-files","dir":"","previous_headings":"","what":"Configuration Files","title":"GitHub Actions CI/CD for HATSA","text":"codecov.yml: Codecov configuration coverage targets ignore patterns DESCRIPTION: Updated covr styler Suggests field","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"badges","dir":"","previous_headings":"","what":"Badges","title":"GitHub Actions CI/CD for HATSA","text":"following badges included main README: - R-CMD-check status - Codecov test coverage - Links GitHub Actions Codecov dashboard","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CI_CD_SETUP.html","id":"status","dir":"","previous_headings":"","what":"Status","title":"GitHub Actions CI/CD for HATSA","text":"✅ workflows ready run ✅ Cross-platform testing (Windows, macOS, Linux) ✅ Multiple R versions (devel, release, oldrel-1) ✅ Code coverage reporting ✅ Automated documentation deployment ✅ Code style enforcement","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"CLAUDE.md","text":"HATSA (Hyperalignment via Task-informed Shared Analysis) R package advanced functional connectivity alignment neuroimaging data. package ~75% complete 5 critical core functions missing.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md","text":"","code":"# Install dependencies (including missing ones from DESCRIPTION) R -e \"install.packages(c('Matrix', 'RANN', 'stats', 'multivarious', 'expm', 'RSpectra', 'PRIMME', 'testthat', 'vegan'))\"  # Run all tests R -e \"devtools::test()\"  # Run specific test file R -e \"devtools::test_file('tests/testthat/test-spectral_graph_construction.R')\"  # Check package (build, tests, examples, documentation) R -e \"devtools::check()\"  # Build and install package locally R -e \"devtools::install()\"  # Document package (rebuild .Rd files from roxygen2 comments) R -e \"devtools::document()\"  # Load package for interactive development R -e \"devtools::load_all()\""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"s3-class-hierarchy","dir":"","previous_headings":"Architecture & Key Components","what":"S3 Class Hierarchy","title":"CLAUDE.md","text":"hatsa_projector: Main projector class, inherits multivarious::multiblock_biprojector task_hatsa_projector: Task-informed variant additional methods","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"core-algorithms","dir":"","previous_headings":"Architecture & Key Components","what":"Core Algorithms","title":"CLAUDE.md","text":"HATSA Core (run_hatsa_core): Base hyperalignment using sparse graph representations Task-HATSA (run_task_hatsa): Extensions lambda blending, GEV patches, anchor augmentation Voxel Projection: Nyström extension mapping full voxel data spectral space","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"critical-missing-functions-priority","dir":"","previous_headings":"Architecture & Key Components","what":"Critical Missing Functions (Priority)","title":"CLAUDE.md","text":"Located R/spectral_graph_construction.R: 1. compute_subject_connectivity_graph_sparse() - Build sparse correlation graphs 2. compute_graph_laplacian_sparse() - Compute normalized Laplacian 3. compute_spectral_sketch_sparse() - Eigendecomposition DC filtering 4. misalign_deg() - (k) geodesic distance metric 5. solve_gev_laplacian_primme() - Generalized eigenvalue solver","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"important-note-on-dependencies","dir":"","previous_headings":"Architecture & Key Components","what":"Important Note on Dependencies","title":"CLAUDE.md","text":"PRIMME: Used sparse eigendecomposition generalized eigenvalue problems (preferred RSpectra speed) dependencies now properly declared DESCRIPTION","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"testing-structure","dir":"","previous_headings":"Architecture & Key Components","what":"Testing Structure","title":"CLAUDE.md","text":"Framework: testthat v3 Test files mirror source structure 400+ tests already written (including missing functions) Snapshot tests use _snaps/ directory","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"important-design-patterns","dir":"","previous_headings":"Architecture & Key Components","what":"Important Design Patterns","title":"CLAUDE.md","text":"sparse matrices use Matrix::dgCMatrix format Subject data format: list T×V matrices (time × voxels) Anchor indices 1-based (R convention) Methods follow S3 dispatch pattern multivarious package Extensive input validation public functions","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"task-hatsa-methods","dir":"","previous_headings":"Mathematical & Implementation Details","what":"Task-HATSA Methods","title":"CLAUDE.md","text":"Lambda blending: Combines connectivity task graphs W = (1-λ)W_conn + λW_task (default λ=0.15) GEV patches: Uses generalized eigenvalue decomposition task-orthogonal eigenvectors Anchor augmentation: Appends task features anchor matrix differential weighting Auto-residualization: task/connectivity correlation > 0.45, task graph residualized","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"graph-construction","dir":"","previous_headings":"Mathematical & Implementation Details","what":"Graph Construction","title":"CLAUDE.md","text":"Laplacian formula: L_rw_lazy = - αD^(-1)W (α=0.93 default) k-NN sparsification: Separate positive/negative edge selection Z-scoring: Applied non-zero edge weights DC filtering: First eigenvector removed spectral decomposition","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"riemannian-geometry-components","dir":"","previous_headings":"Mathematical & Implementation Details","what":"Riemannian Geometry Components","title":"CLAUDE.md","text":"SPD manifold operations: Log-Euclidean AIRM metrics implemented Mitteroecker & Bookstein distance: Primary metric HATSA output analysis Geo-HATSA variant: Uses Fréchet mean (k) geometric rotation updates Tangent space projection: Maps SPD matrices common tangent space analysis","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CLAUDE.html","id":"validation--diagnostics","dir":"","previous_headings":"Mathematical & Implementation Details","what":"Validation & Diagnostics","title":"CLAUDE.md","text":"Anchor selection metrics: Reconstruction error, rotation dispersion, condition number MRA-Select algorithm: Balances condition number Riemannian dispersion Quality metrics: ISC transferability, eigenvalue fidelity, graph correlation Diagnostic plots: k-stability, MDS visualization, eigengap analysis","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to HATSA","title":"Contributing to HATSA","text":"Thank interest contributing HATSA! document provides guidelines contributing project.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"prerequisites","dir":"","previous_headings":"🚀 Getting Started","what":"Prerequisites","title":"Contributing to HATSA","text":"R (≥ 4.0.0) Git GitHub account","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"development-setup","dir":"","previous_headings":"🚀 Getting Started","what":"Development Setup","title":"Contributing to HATSA","text":"Fork clone repository Install development dependencies Load package development","code":"git clone https://github.com/your-username/hatsa.git cd hatsa # Install package development tools install.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"styler\", \"covr\"))  # Install package dependencies devtools::install_deps(dependencies = TRUE) devtools::load_all()"},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"code-standards","dir":"","previous_headings":"🛠️ Development Workflow","what":"Code Standards","title":"Contributing to HATSA","text":"Style: use tidyverse style guide Formatting: Run styler::style_pkg() committing Documentation: functions must complete roxygen2 documentation Testing: New code include comprehensive tests","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"making-changes","dir":"","previous_headings":"🛠️ Development Workflow","what":"Making Changes","title":"Contributing to HATSA","text":"Create feature branch Write code Follow existing code patterns Add comprehensive documentation Include appropriate tests Test changes Style code","code":"git checkout -b feature/your-feature-name # Run tests devtools::test()  # Check package devtools::check()  # Check test coverage covr::package_coverage() styler::style_pkg()"},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"documentation","dir":"","previous_headings":"🛠️ Development Workflow","what":"Documentation","title":"Contributing to HATSA","text":"Functions: exported functions need @param, @return, @examples, @export Classes: S3 classes need clear documentation structure methods Vignettes: Complex features include vignettes examples","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"example-documentation-template","dir":"","previous_headings":"🛠️ Development Workflow > Documentation","what":"Example Documentation Template","title":"Contributing to HATSA","text":"","code":"#' Brief function description #' #' Longer description with details about what the function does. #' #' @param param1 Description of parameter 1 #' @param param2 Description of parameter 2 #' @return Description of what the function returns #' @export #' @examples #' # Example usage #' result <- my_function(param1 = \"value\", param2 = 123)"},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"🛠️ Development Workflow","what":"Testing","title":"Contributing to HATSA","text":"Coverage: Aim >90% test coverage Test types: Unit tests, integration tests, edge cases Test location: Place tests tests/testthat/test-*.R","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"test-structure","dir":"","previous_headings":"🛠️ Development Workflow > Testing","what":"Test Structure","title":"Contributing to HATSA","text":"","code":"test_that(\"function does what it should\", {   # Setup   input <- create_test_data()      # Execute   result <- my_function(input)      # Verify   expect_equal(result$expected_field, expected_value)   expect_true(is.matrix(result$matrix_field)) })"},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"before-submitting","dir":"","previous_headings":"📝 Pull Request Process","what":"Before Submitting","title":"Contributing to HATSA","text":"Ensure checks pass Run full test suite Check code coverage Update documentation","code":"devtools::check() devtools::test() covr::package_coverage() devtools::document()"},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"pr-guidelines","dir":"","previous_headings":"📝 Pull Request Process","what":"PR Guidelines","title":"Contributing to HATSA","text":"Title: Use clear, descriptive title Description: Explain changes made Testing: Describe tested changes Breaking changes: Clearly mark breaking changes","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"pr-template","dir":"","previous_headings":"📝 Pull Request Process","what":"PR Template","title":"Contributing to HATSA","text":"","code":"## Description Brief description of changes  ## Type of Change - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] Documentation update  ## Testing - [ ] Tests pass locally - [ ] Added tests for new functionality - [ ] Updated documentation  ## Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Documentation updated - [ ] Tests added/updated"},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"bug-reports","dir":"","previous_headings":"🐛 Reporting Issues","what":"Bug Reports","title":"Contributing to HATSA","text":"reporting bugs, include: R version: Output sessionInfo() HATSA version: packageVersion(\"hatsa\") Minimal reproducible example Expected vs actual behavior Error messages (full traceback)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"feature-requests","dir":"","previous_headings":"🐛 Reporting Issues","what":"Feature Requests","title":"Contributing to HATSA","text":"feature requests, provide: Use case: feature needed? Proposed solution: work? Alternatives: approaches considered?","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"id_️-project-structure","dir":"","previous_headings":"","what":"🏗️ Project Structure","title":"Contributing to HATSA","text":"","code":"hatsa/ ├── R/                          # Source code │   ├── hatsa_core_algorithm.R  # Main HATSA workflow │   ├── task_hatsa_main.R       # Task-informed extensions │   ├── voxel_projection.R      # Nyström voxel mapping │   └── ...                     # Other modules ├── tests/testthat/             # Test files ├── man/                        # Generated documentation ├── vignettes/                  # Package vignettes ├── .github/workflows/          # CI/CD workflows ├── DESCRIPTION                 # Package metadata └── NAMESPACE                   # Exported functions"},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"learning-resources","dir":"","previous_headings":"📚 Resources","what":"Learning Resources","title":"Contributing to HATSA","text":"R Packages (2nd ed) - Comprehensive guide R package development Advanced R - Deep dive R programming testthat documentation - Testing framework","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"hatsa-specific-resources","dir":"","previous_headings":"📚 Resources","what":"HATSA-Specific Resources","title":"Contributing to HATSA","text":"Mathematical background: See planning-docs/ folder algorithm specifications API documentation: https://bbuchsbaum.github.io/hatsa/ Project status: HATSA_PROJECT_STATUS.md","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"our-standards","dir":"","previous_headings":"🤝 Code of Conduct","what":"Our Standards","title":"Contributing to HATSA","text":"Respectful: respectful constructive discussions Inclusive: Welcome contributors backgrounds Collaborative: Help others learn improve Professional: Maintain professional conduct interactions","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"reporting-issues","dir":"","previous_headings":"🤝 Code of Conduct","what":"Reporting Issues","title":"Contributing to HATSA","text":"experience witness inappropriate behavior, please report brad.buchsbaum@gmail.com.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CONTRIBUTING.html","id":"id_-recognition","dir":"","previous_headings":"","what":"🙏 Recognition","title":"Contributing to HATSA","text":"Contributors acknowledged : Release notes Package documentation GitHub contributors list Thank helping make HATSA better! 🎉","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":null,"dir":"","previous_headings":"","what":"CRITICAL PATH IMPLEMENTATION TICKETS","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Priority: URGENT - 5 functions must implemented HATSA functionality can work.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"ticket-cp-001-compute_subject_connectivity_graph_sparse","dir":"","previous_headings":"","what":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"File: R/spectral_graph_construction.RStatus: ❌ Function signature exists, implementationEstimated Time: 1-2 days","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"function-signature","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Function Signature","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"compute_subject_connectivity_graph_sparse <- function(X_subject, parcel_names, k_conn_pos, k_conn_neg, use_dtw = FALSE)"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"purpose","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Purpose","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Build sparse correlation graphs subject time series data. foundational function creates connectivity matrices used throughout HATSA.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"input","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Input","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"X_subject: Numeric matrix (T x V_p) - time series one subject parcel_names: Character vector length V_p - parcel identifiers k_conn_pos: Integer - number strongest positive connections retain per parcel k_conn_neg: Integer - number strongest negative connections retain per parcel use_dtw: Logical - whether use Dynamic Time Warping (implemented yet)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"expected-output","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Expected Output","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Sparse symmetric matrix (dgCMatrix, V_p x V_p) : - Sparsified correlation values - Z-scored edge weights (non-zero elements) - Symmetric structure - Zero diagonal","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"algorithm","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Algorithm","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Compute full correlation matrix: cor(X_subject) (V_p x V_p) Set diagonal 0 Apply k-NN sparsification separately positive negative correlations Symmetrize: (W + t(W)) / 2 Z-score non-zero edge weights using existing zscore_nonzero_sparse() function Return sparse dgCMatrix","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"dependencies","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Dependencies","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Matrix package (already imported) zscore_nonzero_sparse() function (already implemented)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"tests-ready","dir":"","previous_headings":"TICKET CP-001: compute_subject_connectivity_graph_sparse()","what":"Tests Ready","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"✅ tests/testthat/test-spectral_graph_construction.R lines 15-200","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"ticket-cp-002-compute_graph_laplacian_sparse","dir":"","previous_headings":"","what":"TICKET CP-002: compute_graph_laplacian_sparse()","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"File: R/spectral_graph_construction.RStatus: ❌ Function signature exists, implementationEstimated Time: 1 day","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"function-signature-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Function Signature","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"compute_graph_laplacian_sparse <- function(W_sparse, alpha = 0.93, degree_type = \"abs\")"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"purpose-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Purpose","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Compute alpha-lazy random-walk normalized Laplacian sparse adjacency matrix.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"input-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Input","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"W_sparse: Sparse symmetric matrix (dgCMatrix) - adjacency/weight matrix alpha: Numeric [0,1] - laziness parameter (default 0.93) degree_type: Character - compute degrees (“abs”, “positive”, “signed”)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"mathematical-formula","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Mathematical Formula","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"L = I - alpha * D^(-1) * W where D is degree matrix based on degree_type"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"expected-output-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Expected Output","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Sparse symmetric matrix (dgCMatrix, V_p x V_p): - Alpha-lazy random-walk normalized Laplacian - Symmetric: (L + t(L))/2 - Proper handling zero-degree nodes","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"algorithm-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Algorithm","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"“abs”: rowSums(abs(W_sparse)) “positive”: rowSums(pmax(W_sparse, 0)) “signed”: rowSums(W_sparse) Handle zero degrees: set small epsilon special case Create degree matrix: D_inv = Diagonal(x = 1/degrees) Compute: L_rw = - alpha * D_inv %*% W_sparse Symmetrize: L = (L_rw + t(L_rw)) / 2 Return sparse dgCMatrix","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"dependencies-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Dependencies","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Matrix package (already imported)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"tests-ready-1","dir":"","previous_headings":"TICKET CP-002: compute_graph_laplacian_sparse()","what":"Tests Ready","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"✅ tests/testthat/test-spectral_graph_construction.R lines 295-380","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"ticket-cp-003-compute_spectral_sketch_sparse","dir":"","previous_headings":"","what":"TICKET CP-003: compute_spectral_sketch_sparse()","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"File: R/spectral_graph_construction.RStatus: ❌ Function signature exists, implementationEstimated Time: 1-2 days","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"function-signature-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Function Signature","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"compute_spectral_sketch_sparse <- function(L_sparse, k, eigenvalue_tol = 1e-8)"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"purpose-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Purpose","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Compute sparse eigendecomposition DC component filtering HATSA spectral sketches.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"input-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Input","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"L_sparse: Sparse symmetric matrix (dgCMatrix) - Laplacian matrix k: Integer - number eigenvectors return eigenvalue_tol: Numeric - threshold filtering trivial eigenvectors","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"expected-output-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Expected Output","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"List two elements: - vectors: Numeric matrix (V_p x k) - eigenvectors - values: Numeric vector (length k) - eigenvalues","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"algorithm-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Algorithm","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Determine many eigenvectors request (need k + buffer filtering) Use RSpectra::eigs_sym() compute smallest eigenvalues/vectors Filter trivial eigenvectors eigenvalue < eigenvalue_tol Take first k non-trivial eigenvectors Return list vectors values","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"edge-cases","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Edge Cases","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Handle k = 0: return empty matrices Handle insufficient non-trivial eigenvectors: throw informative error Handle numerical issues eigendecomposition","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"dependencies-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Dependencies","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"RSpectra package (already imported)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"tests-ready-2","dir":"","previous_headings":"TICKET CP-003: compute_spectral_sketch_sparse()","what":"Tests Ready","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"✅ tests/testthat/test-spectral_graph_construction.R lines 400-590","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"ticket-cp-004-misalign_deg","dir":"","previous_headings":"","what":"TICKET CP-004: misalign_deg()","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"File: R/metrics.RStatus: ❌ Exported NAMESPACE implementationEstimated Time: 0.5 days","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"function-signature-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Function Signature","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"misalign_deg <- function(R1, R2, method = \"geodesic\")"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"purpose-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Purpose","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Compute geodesic distance two rotation matrices (k) manifold, returned degrees.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"input-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Input","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"R1, R2: Numeric matrices (k x k) - rotation matrices (k) method: Character - distance computation method (“geodesic”)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"mathematical-formula-1","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Mathematical Formula","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"d = acos((trace(t(R1) %*% R2) - 1) / 2) * 180/π"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"expected-output-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Expected Output","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Numeric scalar - geodesic distance degrees [0, 180]","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"algorithm-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Algorithm","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Validate inputs square matrices dimension Compute trace: tr = sum(diag(t(R1) %*% R2)) tr > k + 1: clamp k + 1 tr < k - 1: clamp k - 1 Compute: d_rad = acos((tr - 1) / 2) Convert degrees: d_deg = d_rad * 180 / pi Return scalar value","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"error-handling","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Error Handling","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Check matrix dimensions match Handle numerical issues acos() Validate rotation matrix properties (optional)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"dependencies-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Dependencies","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Base R ","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"tests-ready-3","dir":"","previous_headings":"TICKET CP-004: misalign_deg()","what":"Tests Ready","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"✅ tests/testthat/test-metrics.R lines 1-150","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"ticket-cp-005-solve_gev_laplacian_primme","dir":"","previous_headings":"","what":"TICKET CP-005: solve_gev_laplacian_primme()","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"File: R/gev_helpers.RStatus: ❌ Exported NAMESPACE implementationEstimated Time: 1 day","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"function-signature-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Function Signature","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"","code":"solve_gev_laplacian_primme <- function(A, B, k_request, lambda_max_thresh = 0.8, epsilon_reg_B = 1e-6, tol = 1e-8)"},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"purpose-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Purpose","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Solve generalized eigenvalue problem Av = λB*v task HATSA GEV patches.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"input-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Input","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":": Sparse symmetric matrix (dgCMatrix) - typically task Laplacian B: Sparse symmetric matrix (dgCMatrix) - typically connectivity Laplacian k_request: Integer - number eigenpairs compute lambda_max_thresh: Numeric - maximum eigenvalue retain epsilon_reg_B: Numeric - regularization B matrix tol: Numeric - convergence tolerance","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"expected-output-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Expected Output","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"List : - vectors: Numeric matrix (V_p x k_filtered) - filtered eigenvectors - values: Numeric vector (length k_filtered) - filtered eigenvalues - n_converged: Integer - number eigenvalues converged - n_filtered: Integer - number retained filtering","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"algorithm-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Algorithm","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Regularize B matrix: B_reg = B + epsilon_reg_B * Use PRIMME::eigs_sym(= , B = B_reg, NEig = k_request, = \"SM\") Filter results: keep eigenvalues abs(lambda) < lambda_max_thresh Return list filtered vectors, values, diagnostic counts","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"error-handling-1","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Error Handling","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"Check matrix dimensions match Handle convergence failures Validate eigenvalue filtering results","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"dependencies-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Dependencies","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"PRIMME package (already imported) Matrix package (already imported)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"tests-ready-4","dir":"","previous_headings":"TICKET CP-005: solve_gev_laplacian_primme()","what":"Tests Ready","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"✅ tests/testthat/test-gev.R lines 30-100","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"day-1-2-foundation","dir":"","previous_headings":"🚀 IMPLEMENTATION ORDER","what":"Day 1-2: Foundation","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"CP-001 (connectivity graphs) - critical, everything depends CP-002 (Laplacian) - Direct dependency spectral sketches","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"day-3-4-core-analysis","dir":"","previous_headings":"🚀 IMPLEMENTATION ORDER","what":"Day 3-4: Core Analysis","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"CP-003 (spectral sketches) - Core eigendecomposition functionality CP-004 (misalign_deg) - Needed validation metrics","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"day-5-advanced-features","dir":"","previous_headings":"🚀 IMPLEMENTATION ORDER","what":"Day 5: Advanced Features","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"CP-005 (GEV solver) - Enables task HATSA GEV patches","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/CRITICAL_PATH_TICKETS.html","id":"id_-validation-workflow","dir":"","previous_headings":"","what":"✅ VALIDATION WORKFLOW","title":"CRITICAL PATH IMPLEMENTATION TICKETS","text":"implementing function: Success Criteria: - function-specific tests pass - run_hatsa_core() executes without errors - Integration tests pass - Task HATSA voxel projection work end--end 🎯 Start CP-001 work list sequentially. function builds previous ones.","code":"# Test specific function R -e \"devtools::test_file('tests/testthat/test-spectral_graph_construction.R')\"  # Test integration   R -e \"devtools::test_file('tests/testthat/test-hatsa_core_functionality.R')\"  # Full test suite (after all 5 implemented) R -e \"devtools::test()\""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":null,"dir":"","previous_headings":"","what":"HATSA Project Status & Completion Roadmap","title":"HATSA Project Status & Completion Roadmap","text":"Status : December 2024Overall Completion: ~95% (core functions implemented, needs polish release)","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"id_-completed-components-100","dir":"","previous_headings":"🎯 CURRENT STATE ASSESSMENT","what":"✅ COMPLETED COMPONENTS (100%)","title":"HATSA Project Status & Completion Roadmap","text":"critical path functions fully implemented tested: ✅ compute_subject_connectivity_graph_sparse() - 73 tests passing ✅ compute_graph_laplacian_sparse() - Fully tested ✅ compute_spectral_sketch_sparse() - Working RSpectra ✅ misalign_deg() - Exported functional ✅ solve_gev_laplacian_primme() - 12 tests passing Test Suite Status: 514 tests PASSING, 0 FAILING ✅","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"critical-missing-dependencies-in-description","dir":"","previous_headings":"🎯 CURRENT STATE ASSESSMENT > ⚠️ ISSUES REQUIRING ATTENTION","what":"CRITICAL: Missing Dependencies in DESCRIPTION","title":"HATSA Project Status & Completion Roadmap","text":"package fails R CMD check due missing dependencies: - Missing Imports: PRIMME, RSpectra, future.apply, ggplot2, methods, vegan - Optional packages declared: MASS, shapes, ggrepel","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"package-metadata-issues","dir":"","previous_headings":"🎯 CURRENT STATE ASSESSMENT > ⚠️ ISSUES REQUIRING ATTENTION","what":"Package Metadata Issues","title":"HATSA Project Status & Completion Roadmap","text":"DESCRIPTION placeholders: Title Description fields contain boilerplate text Version: Still 0.0.0.9000 (pre-release) Author ORCID: Placeholder text “-ORCID-ID”","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"code-quality-issues","dir":"","previous_headings":"🎯 CURRENT STATE ASSESSMENT > ⚠️ ISSUES REQUIRING ATTENTION","what":"Code Quality Issues","title":"HATSA Project Status & Completion Roadmap","text":"Dense correlation matrix computation size guard (V_p^2 > 1e8) Multiple forceSymmetric() + drop0() patterns optimized chunking large correlation matrices alpha = 0.93 (lazy random walk parameter) lambda_max_thresh = 0.8 (GEV filtering) epsilon_reg_B = 1e-6 (regularization) Various tolerance values (1e-8, 1e-9) Mixed parameter naming: k vs k_request vs spectral_rank_k Inconsistent message handling: message() vs message_stage() functions use interactive() guards, others don’t Missing input validation internal functions Inconsistent NA/NaN handling functions silently return empty results Missing roxygen2 docs internal functions TODO comments 2 locations examples missing incomplete","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"deprecation-warnings","dir":"","previous_headings":"🎯 CURRENT STATE ASSESSMENT > ⚠️ ISSUES REQUIRING ATTENTION","what":"Deprecation Warnings","title":"HATSA Project Status & Completion Roadmap","text":"Matrix package: (<dsCMatrix>, \"dgCMatrix\") deprecated testthat: context() deprecated Import conflict: PRIMME::eigs_sym vs RSpectra::eigs_sym","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-fix-001-update-description-file","dir":"","previous_headings":"📋 IMMEDIATE PRIORITIES (1-2 days)","what":"TICKET FIX-001: Update DESCRIPTION File","title":"HATSA Project Status & Completion Roadmap","text":"Priority: 🔴 CRITICAL Tasks: Update metadata: Proper Title, Description, Version (0.1.0) Estimated Time: 30 minutes","code":"# Add to Imports: Imports:      Matrix,     RANN,     stats,     multivarious,     expm,     RSpectra,     PRIMME,     future.apply,     ggplot2,     methods,     vegan  # Add to Suggests: Suggests:     testthat (>= 3.0.0),     knitr,     rmarkdown,     MASS,     shapes,     ggrepel"},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-fix-002-resolve-import-conflicts","dir":"","previous_headings":"📋 IMMEDIATE PRIORITIES (1-2 days)","what":"TICKET FIX-002: Resolve Import Conflicts","title":"HATSA Project Status & Completion Roadmap","text":"Priority: 🟡 HIGH Issue: PRIMME RSpectra export eigs_sym Solution: Use explicit namespace calls choose one package File: NAMESPACE relevant R files Estimated Time: 1 hour","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-fix-003-fix-deprecation-warnings","dir":"","previous_headings":"📋 IMMEDIATE PRIORITIES (1-2 days)","what":"TICKET FIX-003: Fix Deprecation Warnings","title":"HATSA Project Status & Completion Roadmap","text":"Priority: 🟡 HIGH Replace (<dsCMatrix>, \"dgCMatrix\") (., \"generalMatrix\") Update testthat context() describe() Fix roxygen2 @importFrom errors Estimated Time: 2 hours","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-opt-001-efficient-sparse-correlation","dir":"","previous_headings":"🔧 OPTIMIZATION OPPORTUNITIES (Week 1)","what":"TICKET OPT-001: Efficient Sparse Correlation","title":"HATSA Project Status & Completion Roadmap","text":"Current: Dense correlation parcels Proposed: Implement chunked approximate methods large V_p Benefits: Memory efficiency V_p > 1000 File: R/spectral_graph_construction.R","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-opt-002-parameterize-hardcoded-values","dir":"","previous_headings":"🔧 OPTIMIZATION OPPORTUNITIES (Week 1)","what":"TICKET OPT-002: Parameterize Hardcoded Values","title":"HATSA Project Status & Completion Roadmap","text":"Tolerance values Default parameters (alpha, lambda_max_thresh, etc.) Eigenvalue thresholds Consider: Package-level options via options()","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"ticket-opt-003-standardize-interfaces","dir":"","previous_headings":"🔧 OPTIMIZATION OPPORTUNITIES (Week 1)","what":"TICKET OPT-003: Standardize Interfaces","title":"HATSA Project Status & Completion Roadmap","text":"Harmonize parameter names across functions Create consistent message system Standardize error handling patterns","code":""},{"path":[]},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"week-1-critical-fixes","dir":"","previous_headings":"🚀 PATH TO CRAN RELEASE","what":"Week 1: Critical Fixes","title":"HATSA Project Status & Completion Roadmap","text":"Fix DESCRIPTION dependencies (FIX-001) Resolve import conflicts (FIX-002) Fix deprecation warnings (FIX-003) Run full R CMD check clean","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"week-2-polish--optimization","dir":"","previous_headings":"🚀 PATH TO CRAN RELEASE","what":"Week 2: Polish & Optimization","title":"HATSA Project Status & Completion Roadmap","text":"Implement efficiency improvements (OPT-001) Parameterize hardcoded values (OPT-002) Standardize interfaces (OPT-003) Complete missing documentation","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"week-3-release-preparation","dir":"","previous_headings":"🚀 PATH TO CRAN RELEASE","what":"Week 3: Release Preparation","title":"HATSA Project Status & Completion Roadmap","text":"Version bump 1.0.0 NEWS.md file creation CRAN submission checklist Final testing multiple platforms","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"id_-technical-debt--future-improvements","dir":"","previous_headings":"","what":"💡 TECHNICAL DEBT & FUTURE IMPROVEMENTS","title":"HATSA Project Status & Completion Roadmap","text":"DTW Support: Currently placeholder connectivity computation Memory Optimization: Better handling large-scale problems Parallel Processing: extensive use future.apply GPU Acceleration: Consider eigendecomposition Approximate Methods: large datasets (V_p > 10,000)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/HATSA_PROJECT_STATUS.html","id":"id_-summary","dir":"","previous_headings":"","what":"✨ SUMMARY","title":"HATSA Project Status & Completion Roadmap","text":"HATSA package functionally complete excellent test coverage. main barriers release : 1. Missing package dependencies DESCRIPTION 2. Minor code quality issues 3. Documentation polish Estimated time production-ready: 1-2 weeks focused development Recommendation: Fix critical dependency issues first (1-2 days), focus optimization polish CRAN submission.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/core-hatsa-toy-example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Core HATSA with a Toy-Connectome","text":"vignette demonstrates core functionality hatsa package using synthetic “Toy-Connectome” generator. generator creates data known ground-truth spectral basis subject-specific rotations, allowing us test HATSA’s ability recover parameters. key properties synthetic data : Known ground-truth spectral basis (U_true): Enables direct comparison learned basis. Known subject-specific rotations (R_true_list): Allows quantitative assessment HATSA’s alignment accuracy. Realistic correlation structure: underlying graph (ring graph) AR(1) latent dynamics ensure resulting Laplacians clear eigengaps anchor parcels lie smooth manifold. Time-series data: generator produces subject-specific time-series matrices (X_list), standard input full HATSA pipeline (graph construction, Laplacian computation, spectral sketching). Controllable signal--noise ratio (SNR) eigengap: Allows stress-testing algorithm.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/core-hatsa-toy-example.html","id":"toy-connectome-generator","dir":"Articles","previous_headings":"","what":"Toy-Connectome Generator","title":"Core HATSA with a Toy-Connectome","text":"following functions define toy-connectome generator helper calculate misalignment angles.","code":"suppressPackageStartupMessages({   library(Matrix)  # For sparse matrices   library(RSpectra) # For fast partial eigendecompositions   # library(hatsa) # Will be loaded explicitly when used   # expm is suggested by misalign_deg, which is now a package function })  # The misalign_deg function is now part of the hatsa package and will be available # after library(hatsa) is called in the next chunk. # The safe_logm helper is internal to that function.  #' Generate Toy Data for Core HATSA #' #' Creates synthetic time-series data for multiple subjects with a known #' underlying spectral structure and subject-specific rotations. #' This version incorporates feedback for improved realism and correctness. #' #' @param V Integer, number of parcels (nodes). Default 40. #' @param k Integer, spectral rank (number of eigenvectors). Default 5. #' @param Nsubj Integer, number of subjects. Default 6. #' @param Tlen Integer, number of time points per subject. Default 300. #' @param snr Numeric, signal-to-noise ratio. Default 2.5. #' @param seed Integer, random seed for reproducibility. Default 42. #' @param phi Numeric, AR(1) coefficient for latent dynamics. Default 0.6. #' @return A list containing: #'   \\itemize{ #'     \\item{`X_list`}{A list of `Nsubj` matrices, each `Tlen x V`, representing subject time-series data.} #'     \\item{`U_true`}{The `V x k` ground-truth spectral basis (eigenvectors).} #'     \\item{`R_true_list`}{A list of `Nsubj` `k x k` ground-truth rotation matrices.} #'     \\item{`L_true_ring`}{The `V x V` true ring Laplacian matrix used.} #'     \\item{`eigenvalues_true`}{The first `k` eigenvalues of `L_true_ring`.} #'   } make_toy_hatsa <- function(V=40, k=5, Nsubj=6, Tlen=300,                            snr=2.5, seed=42, phi=0.6){   set.seed(seed)   ## Ring adjacency (wrap-around)   ringW <- Matrix::sparseMatrix(       i = c(1:(V-1),   2:V, V, 1),       j = c(2:V,       1:(V-1),1,V),       x = 1, dims = c(V,V))   D <- Matrix::Diagonal(x = Matrix::rowSums(ringW))   L <- D - ringW   e  <- RSpectra::eigs_sym(L, k = k, which = \"SA\")   U0 <- e$vectors    rand_SO <- function(p){     Q <- qr.Q(qr(matrix(rnorm(p*p),p)))     if(det(Q)<0) Q[,p] <- -Q[,p] # Corrected: flip last column for SO(k)     Q}   R_list <- replicate(Nsubj, rand_SO(k), simplify = FALSE)    latent <- function(){     Z <- matrix(0,Tlen,k)     # Initialize with stationary variance for AR(1) if phi < 1     if (abs(phi) < 1) {         Z[1,] <- rnorm(k, sd = sqrt(1 / (1 - phi^2)))     } else {         Z[1,] <- rnorm(k)     }     for(t in 2:Tlen) Z[t,] <- phi*Z[t-1,] + rnorm(k)     Z}    X_list <- lapply(R_list, function(Ri){       sig <- latent() %*% t(Ri) %*% t(U0)      # T x V       # Simplified SNR calculation based on review       sd_n <- sqrt(mean(apply(sig,2,var, na.rm=TRUE), na.rm=TRUE)/snr)       if(is.na(sd_n) || sd_n == 0) sd_n <- 1e-6 # ensure some noise if signal is flat       sig + matrix(rnorm(Tlen*V,sd=sd_n),Tlen,V,                    dimnames=list(NULL,paste0(\"P\",1:V)))   })    list(X_list=X_list,U_true=U0,R_true_list=R_list,        L_true_ring=L,eigenvalues_true=e$values[1:k]) # Return only the k eigenvalues for U0 }  # Helper for safe matrix logarithm, returning NULL on error safe_logm <- function(M) {   res <- tryCatch(     expm::logm(M),     error = function(e) {       warning(paste(\"Matrix logarithm failed:\", e$message, \". Using trace-based heuristic for misalignment.\"))       return(NULL)     }   )   return(res) }"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/core-hatsa-toy-example.html","id":"running-core-hatsa-on-toy-data","dir":"Articles","previous_headings":"","what":"Running Core HATSA on Toy Data","title":"Core HATSA with a Toy-Connectome","text":"Now, let’s generate toy data run core HATSA algorithm.","code":"# Load hatsa package if not already loaded if (!requireNamespace(\"hatsa\", quietly = TRUE)) {   stop(\"Please install the 'hatsa' package to run this vignette.\") } library(hatsa)  # 1. Generate Toy Data set.seed(123) # For reproducibility of this vignette run toy_data <- make_toy_hatsa(V = 40, k = 5, Nsubj = 6, Tlen = 300, snr = 2.5, phi = 0.6)  X_list_toy <- toy_data$X_list U_true_toy <- toy_data$U_true R_true_list_toy <- toy_data$R_true_list  # 2. Set up parameters for run_task_hatsa (core HATSA mode) # Anchor selection: For simplicity, let's pick the first 10 parcels as anchors. # In a real scenario, anchor selection would be more data-driven. anchor_indices_toy <- 1:10  k_spectral_rank_toy <- 5 # Must match k from toy data generation for meaningful comparison  # HATSA parameters (using defaults or simple values for demonstration) # Refer to `?run_task_hatsa` for detailed parameter descriptions. params_core_hatsa <- list(   subject_data_list = X_list_toy,   task_data_list = NULL, # Indicates core_hatsa method   anchor_indices = anchor_indices_toy,   spectral_rank_k = k_spectral_rank_toy,   # Vp and Nsub can often be inferred, but good to be explicit if known   Vp = ncol(X_list_toy[[1]]),    Nsub = length(X_list_toy),      # Graph construction and refinement parameters (using some defaults)   k_conn_pos = 7,       # For k-NN graph construction   k_conn_neg = 7,       # For k-NN graph construction (negative weights)   n_refine = 2,         # Number of GPA refinement iterations   alpha_laplacian = 0.95, # For lazy random walk Laplacian      # GPA parameters - gpa_method is handled internally      # Control verbosity and parallel processing   verbose = FALSE,   future_plan = \"sequential\" # For deterministic vignette run )  # 3. Run Core HATSA # We use run_task_hatsa with task_data_list = NULL for core HATSA. # Set future plan for sequential execution for deterministic vignette run if (requireNamespace(\"future\", quietly = TRUE)) {   old_plan <- future::plan(future::sequential)   on.exit(future::plan(old_plan), add = TRUE) } else {   # If future is not available, run_task_hatsa should handle sequential execution by default   # or its internal future_lapply calls will default to sequential. }  message(\"Running Core HATSA on toy data...\") #> Running Core HATSA on toy data... # Corrected argument names as per typical run_task_hatsa signature # Vp and Nsub are usually inferred within run_task_hatsa or its helpers hatsa_results_toy <- run_task_hatsa(     subject_data_list = X_list_toy,     task_data_list    = NULL,             # Ensures core_hatsa method is triggered     anchor_indices    = anchor_indices_toy,     spectral_rank_k   = k_spectral_rank_toy, # Corrected name     task_method       = \"core_hatsa\",     # Explicitly core_hatsa (though NULL task_data_list implies it)     k_conn_pos        = 7,      k_conn_neg        = 7,      n_refine          = 2,      alpha_laplacian   = 0.95, # Example value, adjust as needed     verbose           = FALSE     # future_plan argument removed; managed by future::plan() above ) #> Warning in run_task_hatsa(subject_data_list = X_list_toy, task_data_list = #> NULL, : run_task_hatsa() is kept for backward compatibility; new code should #> call task_hatsa() message(\"Core HATSA run complete.\") #> Core HATSA run complete.  # 4. Extract Estimated Rotations R_est_list_toy <- hatsa_results_toy$R_final_list  # 5. Evaluate Misalignment misalignment_scores <- sapply(1:length(R_est_list_toy), function(i) {   misalign_deg(R_est_list_toy[[i]], R_true_list_toy[[i]]) })  print(\"Misalignment angles (degrees) between estimated and true rotations:\") #> [1] \"Misalignment angles (degrees) between estimated and true rotations:\" print(misalignment_scores) #> [1] 174.4600 169.3468 164.2563 172.1510 156.9429 157.4501  # We can also check the mean misalignment print(paste(\"Mean misalignment angle:\", round(mean(misalignment_scores), 2), \"degrees\")) #> [1] \"Mean misalignment angle: 165.77 degrees\"  # For an SNR of 2.5, we expect relatively low misalignment angles (e.g., < 10-15 degrees for a reasonable SNR like 2.5, and ideally lower as suggested by the original prompt <5 degrees) # The exact values depend on the noise realization and the specific k. # The user's original example mentioned < ~5 degrees for SNR=2.5. The geodesic distance # might yield slightly different values but should be consistently small for good recovery.  # Optionally, compare the estimated group template `hatsa_results_toy$v` with `U_true_toy` # This requires aligning them first, as they are unique up to an orthogonal transformation. # For example, using Procrustes: procrustes_align_v <- function(est_v, true_U) {   if (!requireNamespace(\"vegan\", quietly = TRUE)) {     warning(\"vegan package not available for Procrustes alignment of group template.\")     return(list(aligned_v = est_v, rotation = diag(ncol(est_v)), call = NULL))   }   # vegan::procrustes expects Y, X where Y is target (true_U)   # It finds X %*% R ~ Y   # So, est_v %*% R ~ true_U. We want to rotate est_v.   res_proc <- vegan::procrustes(X = true_U, Y = est_v, symmetric = FALSE)   # res_proc$Yrot is est_v rotated to match true_U   # res_proc$rotation is the rotation matrix applied to Y (est_v)   return(list(aligned_v = res_proc$Yrot, rotation = res_proc$rotation, procrustes_result = res_proc)) }  # alignment_group_v <- procrustes_align_v(hatsa_results_toy$v, U_true_toy) # plot(as.vector(U_true_toy), as.vector(alignment_group_v$aligned_v),  #      xlab = \"True U0 (flattened)\", ylab = \"Estimated V aligned (flattened)\", #      main = \"Group Template Alignment\") # abline(0,1, col=\"red\") # cor_val <- cor(as.vector(U_true_toy), as.vector(alignment_group_v$aligned_v)) # print(paste(\"Correlation between true U0 and aligned estimated V:\", round(cor_val, 3))) # Note: The global sign of eigenvectors can be ambiguous. Procrustes handles this."},{"path":"https://bbuchsbaum.github.io/hatsa/articles/core-hatsa-toy-example.html","id":"interpreting-the-results","dir":"Articles","previous_headings":"","what":"Interpreting the Results","title":"Core HATSA with a Toy-Connectome","text":"primary output assessing HATSA’s core performance toy example list misalignment angles. Small angles (e.g., typically less 10-15 degrees reasonable SNR like 2.5, ideally lower suggested original prompt <5 degrees) indicate HATSA successfully recovered subject-specific rotations. make_toy_hatsa generator designed : * Known Rotations: Directly tests Generalized Procrustes Analysis (GPA) component HATSA. * Ring Laplacian Basis: eigenvectors ring graph smooth (Fourier-like bases), provides good test case spectral methods. choice anchors can related smooth underlying components. * Adjustable SNR: Allows testing robustness HATSA noise. Lowering SNR (e.g., 1.0 less) generally lead higher misalignment angles. * AR(1) Latent Dynamics: generates time series temporal auto-correlation, making synthetic data realistic methods estimate connectivity time series.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/core-hatsa-toy-example.html","id":"potential-extensions","dir":"Articles","previous_headings":"","what":"Potential Extensions","title":"Core HATSA with a Toy-Connectome","text":"toy-connectome generator can extended test various aspects HATSA: Anchor Mis-placement: Systematically alter anchor_indices (e.g., dropping anchor shifting indices) evaluate stability solution. Missing Data: Introduce missing parcels (e.g., zeroing columns X_list subjects) test robustness incomplete data. Task Data Simulation: Extend latent dynamics include event-locked responses, generate corresponding beta maps activation patterns, use test task-guided HATSA variants (though vignette focuses core HATSA). simple, deterministic toy example provides powerful way understand, debug, validate core HATSA algorithm.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"getting-started-with-hatsa","dir":"Articles","previous_headings":"","what":"Getting Started with HATSA","title":"Getting Started with HATSA","text":"HATSA (Hyperalignment via Task-informed Shared Analysis) provides state---art methods aligning functional brain data across subjects. guide get started quickly.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Installation","title":"Getting Started with HATSA","text":"","code":"# Install from GitHub devtools::install_github(\"bbuchsbaum/hatsa\") library(hatsa)"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"your-first-alignment","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Your First Alignment","title":"Getting Started with HATSA","text":"simplest way use HATSA hatsa() function:","code":"# Assume you have a list of subject data matrices # Each matrix is timepoints × voxels result <- hatsa(subject_data)  # That's it! HATSA automatically: # - Selects optimal anchors # - Chooses appropriate parameters # - Performs the alignment"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"understanding-your-results","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Understanding Your Results","title":"Getting Started with HATSA","text":"HATSA provides simple functions explore results:","code":"# Get a quick summary hatsa_summary(result)  # Extract aligned data aligned_data <- get_aligned_data(result)  # Get the group template template <- get_template(result)  # Visualize alignment quality plot_hatsa(result, type = \"eigenvalues\")"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"choosing-parameters","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Choosing Parameters","title":"Getting Started with HATSA","text":"sure parameters use? Let HATSA help:","code":"# Get suggestions based on your data params <- hatsa_suggest(subject_data)  # Use the suggestions result <- hatsa(subject_data,                  components = params$components,                 preset = params$preset)"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"task-informed-alignment","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Task-Informed Alignment","title":"Getting Started with HATSA","text":"task information, HATSA can use improve alignment:","code":"# Automatic method selection result <- hatsa_task(subject_data, task_data)  # Or choose a specific method result <- hatsa_task(subject_data, task_data, method = \"blend\")"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"presets-for-different-scenarios","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Presets for Different Scenarios","title":"Getting Started with HATSA","text":"HATSA includes presets optimized different use cases:","code":"# Fast mode for exploration result_fast <- hatsa(subject_data, preset = \"fast\")  # Accurate mode for final analyses   result_accurate <- hatsa(subject_data, preset = \"accurate\")  # Default balanced mode result_default <- hatsa(subject_data, preset = \"default\")"},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Next Steps","title":"Getting Started with HATSA","text":"Read Task-HATSA Guide task-informed analyses See Advanced Usage custom configurations Check Troubleshooting common issues","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/articles/getting-started.html","id":"getting-help","dir":"Articles","previous_headings":"Getting Started with HATSA","what":"Getting Help","title":"Getting Started with HATSA","text":"","code":"# Built-in documentation ?hatsa ?hatsa_task  # Parameter validation hatsa_validate_params(subject_data,                        anchor_indices = my_anchors,                       spectral_rank_k = 30)"},{"path":"https://bbuchsbaum.github.io/hatsa/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brad Buchsbaum. Author, maintainer.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Buchsbaum B (2025). hatsa: Hyperalignment via Task-informed Shared Analysis. R package version 0.1.0, https://bbuchsbaum.github.io/hatsa/.","code":"@Manual{,   title = {hatsa: Hyperalignment via Task-informed Shared Analysis},   author = {Brad Buchsbaum},   year = {2025},   note = {R package version 0.1.0},   url = {https://bbuchsbaum.github.io/hatsa/}, }"},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"hatsa-hyperalignment-via-task-informed-shared-analysis","dir":"","previous_headings":"","what":"Hyperalignment via Task-informed Shared Analysis","title":"Hyperalignment via Task-informed Shared Analysis","text":"R Package advanced functional connectivity alignment task-informed features","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-current-status","dir":"","previous_headings":"","what":"🎯 Current Status","title":"Hyperalignment via Task-informed Shared Analysis","text":"HATSA package implements advanced hyperalignment methods functional neuroimaging data, major components critical path functions implemented.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-quick-start","dir":"","previous_headings":"","what":"🚀 Quick Start","title":"Hyperalignment via Task-informed Shared Analysis","text":"📊 Progress: ~95% complete 📋 Current Focus: Package polish optimization tasks (status details) ⏱️ Estimated Completion: 1-2 weeks","code":"# Install the package devtools::install_github(\"bbuchsbaum/hatsa\") library(hatsa)  # Basic usage - automatic everything! result <- hatsa(subject_data)  # Get aligned data and check quality aligned <- get_aligned_data(result) hatsa_summary(result)  # Task-informed variant result <- hatsa_task(subject_data, task_data, method = \"auto\")"},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-quick-start-once-complete","dir":"","previous_headings":"","what":"🚀 Quick Start (Once Complete)","title":"Hyperalignment via Task-informed Shared Analysis","text":"","code":"# Install development version devtools::install_github(\"bbuchsbaum/hatsa\")  # Basic HATSA alignment library(hatsa) result <- run_hatsa_core(   subject_data_list = my_timeseries,   anchor_indices = c(1, 15, 23, 45, 67),   spectral_rank_k = 20 )  # Task-informed HATSA   task_result <- run_task_hatsa(   subject_data_list = my_timeseries,   task_data_list = my_activation_maps,   anchor_indices = c(1, 15, 23, 45, 67),   spectral_rank_k = 20,   task_method = \"lambda_blend\" )  # Project voxel data using Nyström extension voxel_projections <- project_voxels(   result,    voxel_timeseries_list = my_voxel_data,   voxel_coords = voxel_coordinates,   parcel_coords = parcel_centroids )"},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"core-architecture-100","dir":"","previous_headings":"✅ What’s Implemented","what":"Core Architecture (100%)","title":"Hyperalignment via Task-informed Shared Analysis","text":"✅ Full S3 class system (hatsa_projector, task_hatsa_projector) ✅ Integration multivarious package ecosystem ✅ Comprehensive documentation examples ✅ Extensive test suite (400+ test cases)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"advanced-features-95","dir":"","previous_headings":"✅ What’s Implemented","what":"Advanced Features (95%)","title":"Hyperalignment via Task-informed Shared Analysis","text":"✅ Task-informed HATSA: Lambda blending GEV patches ✅ Voxel projection: Complete Nyström extension implementation ✅ Weighted alignment: Omega-weighted Procrustes refinement ✅ Riemannian geometry: SPD manifold operations ✅ Validation metrics: Alignment quality assessment","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"specialized-modules-90","dir":"","previous_headings":"✅ What’s Implemented","what":"Specialized Modules (90%)","title":"Hyperalignment via Task-informed Shared Analysis","text":"✅ Anchor selection optimization ✅ Quality control plotting diagnostics ✅ Graph construction methods ✅ Projection transformation utilities","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-critical-path-completed","dir":"","previous_headings":"","what":"✅ Critical Path Completed","title":"Hyperalignment via Task-informed Shared Analysis","text":"five foundational functions fully implemented tested: compute_subject_connectivity_graph_sparse() - Sparse correlation graphs compute_graph_laplacian_sparse() - Laplacian computation compute_spectral_sketch_sparse() - Eigendecomposition misalign_deg() - (k) geodesic distance solve_gev_laplacian_primme() - Generalized eigenvalue solver 📋 Detailed status: See HATSA_PROJECT_STATUS.md","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-documentation","dir":"","previous_headings":"","what":"📖 Documentation","title":"Hyperalignment via Task-informed Shared Analysis","text":"Project Status & Roadmap - Current state completion plan Archived Planning Docs - Original design documents mathematical foundations Package Documentation - Function references examples Test Suite - Comprehensive test coverage","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-development-setup","dir":"","previous_headings":"","what":"🔧 Development Setup","title":"Hyperalignment via Task-informed Shared Analysis","text":"","code":"# Clone and setup git clone https://github.com/bbuchsbaum/hatsa.git cd hatsa  # Install dependencies R -e \"install.packages(c('Matrix', 'RSpectra', 'PRIMME', 'expm', 'multivarious'))\"  # Test current state (all tests should pass) R -e \"devtools::test()\"  # Check package structure R -e \"devtools::check()\""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"required-dependencies","dir":"","previous_headings":"🔧 Development Setup","what":"Required Dependencies","title":"Hyperalignment via Task-informed Shared Analysis","text":"Matrix - Sparse matrix operations RSpectra - Sparse eigendecomposition PRIMME - Generalized eigenvalue problems expm - Matrix exponential/logarithm multivarious - S3 projector framework","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"immediate-priority-week-1","dir":"","previous_headings":"🎯 Next Steps for Contributors","what":"Immediate Priority (Week 1)","title":"Hyperalignment via Task-informed Shared Analysis","text":"Address remaining polish tasks outlined HATSA_PROJECT_STATUS.md: Update DESCRIPTION dependencies Resolve import conflicts Fix deprecation warnings","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"integration-testing-week-2","dir":"","previous_headings":"🎯 Next Steps for Contributors","what":"Integration Testing (Week 2)","title":"Hyperalignment via Task-informed Shared Analysis","text":"Validate full HATSA pipeline Test task-informed extensions Verify voxel projection functionality Performance optimization","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"ready-for-testing","dir":"","previous_headings":"🎯 Next Steps for Contributors","what":"Ready for Testing","title":"Hyperalignment via Task-informed Shared Analysis","text":"✅ Comprehensive test suite already written ✅ Mathematical specifications documented ✅ Function signatures defined ✅ Expected outputs specified","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_️-architecture-overview","dir":"","previous_headings":"","what":"🏗️ Architecture Overview","title":"Hyperalignment via Task-informed Shared Analysis","text":"","code":"hatsa/ ├── R/ │   ├── hatsa_core_algorithm.R      # Main HATSA workflow │   ├── task_hatsa_main.R           # Task-informed extensions │   ├── voxel_projection.R          # Nyström voxel mapping │   ├── spectral_graph_construction.R  # Core functions implemented │   ├── riemannian_geometry.R       # SPD manifold operations │   └── [18 other modules]          # Specialized functionality ├── tests/testthat/ │   ├── test-hatsa_core_functionality.R │   ├── test-spectral_graph_construction.R  # Ready to test │   └── [9 other test files] └── planning-docs/                  # Archived planning documents"},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-contributing","dir":"","previous_headings":"","what":"🤝 Contributing","title":"Hyperalignment via Task-informed Shared Analysis","text":"Focus Polish: Finalize documentation dependency fixes Follow Test-Driven Development: Comprehensive tests already exist Reference Documentation: Mathematical specs planning-docs/ folder Check Integration: Ensure functions work existing S3 methods","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/index.html","id":"id_-license","dir":"","previous_headings":"","what":"📜 License","title":"Hyperalignment via Task-informed Shared Analysis","text":"MIT License - See LICENSE file details. 🎯 Ready complete project? Start HATSA_PROJECT_STATUS.md detailed implementation tickets.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/airm_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","title":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","text":"Computes Affine-Invariant Riemannian Metric (AIRM) distance two symmetric positive-definite (SPD) matrices S1 S2. distance defined : `||logm(S1^(-1/2)  `||.||_F` Frobenius norm.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/airm_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","text":"","code":"airm_distance(S1, S2, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/airm_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","text":"S1 numeric, symmetric positive-definite matrix. S2 numeric, symmetric positive-definite matrix. regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/airm_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","text":"AIRM distance (non-negative scalar).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/airm_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Affine-Invariant Riemannian Metric (AIRM) Distance — airm_distance","text":"","code":"S1 <- matrix(c(2.3, -0.3, -0.3, 3.6), 2, 2) S2 <- matrix(c(3.7, 1.9, 1.9, 2.8), 2, 2) # dist_airm <- airm_distance(S1, S2) # print(dist_airm) # dist_logeuclidean <- riemannian_distance_spd(S1, S2) # print(dist_logeuclidean) # Note: AIRM and LogEuclidean are different metrics."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/anchor-selection-enhanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Enhanced MRA Anchor Selection with Parcel Quality Integration — anchor-selection-enhanced","title":"Enhanced MRA Anchor Selection with Parcel Quality Integration — anchor-selection-enhanced","text":"Extensions MRA anchor selection algorithm incorporate parcel quality information selection process.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/anchor-selection-workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Anchor Selection Workflow for HATSA — anchor-selection-workflow","title":"Anchor Selection Workflow for HATSA — anchor-selection-workflow","text":"Functions support two-phase workflow: 1) Anchor discovery/validation training data 2) Production use validated anchors","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/blend_laplacians.html","id":null,"dir":"Reference","previous_headings":"","what":"Blend Connectivity and Task Laplacians — blend_laplacians","title":"Blend Connectivity and Task Laplacians — blend_laplacians","text":"Combines connectivity-based Laplacian task-based Laplacian using specified blending method. Currently, linear blending supported.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/blend_laplacians.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blend Connectivity and Task Laplacians — blend_laplacians","text":"","code":"blend_laplacians(L_conn, L_task, lambda_blend_value, method = \"linear\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/blend_laplacians.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blend Connectivity and Task Laplacians — blend_laplacians","text":"L_conn sparse Laplacian matrix derived connectivity (`dgCMatrix`, `V_p x V_p`). L_task sparse Laplacian matrix derived task activations/encodings (`dgCMatrix`, `V_p x V_p`). Must dimensions `L_conn`. lambda_blend_value Numeric, blending factor (`λ`). Must 0 1. `L_hybrid = (1 - λ) * L_conn + λ * L_task`. method Character string, blending method. Currently \"linear\" supported.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/blend_laplacians.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blend Connectivity and Task Laplacians — blend_laplacians","text":"blended sparse Laplacian matrix `L_hybrid` (`dgCMatrix`, `V_p x V_p`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/block_indices.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract block indices from a hatsa_projector object — block_indices.hatsa_projector","title":"Extract block indices from a hatsa_projector object — block_indices.hatsa_projector","text":"indices map rows scores matrix (s) respective blocks (subjects).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/block_indices.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract block indices from a hatsa_projector object — block_indices.hatsa_projector","text":"","code":"block_indices.hatsa_projector(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/block_indices.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract block indices from a hatsa_projector object — block_indices.hatsa_projector","text":"x hatsa_projector object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/block_indices.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract block indices from a hatsa_projector object — block_indices.hatsa_projector","text":"list block indices.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/build_augmented_anchor_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","title":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","text":"Combines parcel anchors projected task features single   augmented anchor matrix Procrustes alignment.   inputs different numeric types (e.g. integer double), result   coerced per R's default rules (usually general type).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/build_augmented_anchor_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","text":"","code":"build_augmented_anchor_matrix(A_parcel_anchors, Z_task_features_projected)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/build_augmented_anchor_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","text":"A_parcel_anchors numeric matrix representing parcel anchors, typically dimensions `m_parcels x k_dims`. Z_task_features_projected numeric matrix representing projected task features (e.g., condition means spectral space), typically dimensions `m_task_features x k_dims`. Can `NULL` 0 rows task features added.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/build_augmented_anchor_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","text":"augmented numeric matrix dimensions   `(m_parcels + m_task_features) x k_dims`.   Row names combined inputs (made unique `make.unique`).   Column names taken `A_parcel_anchors` rows;   otherwise `Z_task_features_projected`. error thrown   differing non-NULL column names.   `Z_task_features_projected` `NULL` 0 rows, `A_parcel_anchors` returned.   `A_parcel_anchors` 0 rows `Z_task_features_projected` valid,   `Z_task_features_projected` returned.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/build_augmented_anchor_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Augmented Anchor Matrix — build_augmented_anchor_matrix","text":"","code":"m_parcels <- 5; m_task <- 3; k_dims <- 4 A_p <- matrix(rnorm(m_parcels*k_dims), m_parcels, k_dims, dimnames=list(paste0(\"p\",1:m_parcels), paste0(\"k\",1:k_dims))) Z_t <- matrix(rnorm(m_task*k_dims), m_task, k_dims, dimnames=list(paste0(\"t\",1:m_task), paste0(\"k\",1:k_dims))) A_aug <- build_augmented_anchor_matrix(A_p, Z_t) print(dimnames(A_aug)) #> [[1]] #> [1] \"p1\" \"p2\" \"p3\" \"p4\" \"p5\" \"t1\" \"t2\" \"t3\" #>  #> [[2]] #> [1] \"k1\" \"k2\" \"k3\" \"k4\" #>   # Differing colnames should error Z_t_bad_colnames <- Z_t; colnames(Z_t_bad_colnames) <- paste0(\"dim\",1:k_dims) try(build_augmented_anchor_matrix(A_p, Z_t_bad_colnames)) #> Error in build_augmented_anchor_matrix(A_p, Z_t_bad_colnames) :  #>   Column names/order differ between A_parcel_anchors and Z_task_features_projected; please align before binding."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/bures_wasserstein_barycenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","title":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","text":"Calculates Bures-Wasserstein (BW) barycenter list symmetric positive-definite (SPD) matrices. BW barycenter geodesic mean BW metric. function implements iterative algorithm.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/bures_wasserstein_barycenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","text":"","code":"bures_wasserstein_barycenter(   S_list,   weights = NULL,   initial_mean = NULL,   max_iter = 50,   tol = 1e-07,   regularize_epsilon = 1e-06,   verbose = FALSE,   damping = 0.5 )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/bures_wasserstein_barycenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","text":"S_list list SPD matrices (p x p). weights Optional. numeric vector non-negative weights matrix `S_list`. NULL (default), uniform weights (1/N) used. Must sum 1 provided, normalized. initial_mean Optional. p x p SPD matrix use initial estimate barycenter. NULL, (weighted) arithmetic mean `S_list` used regularization. max_iter Integer, maximum number iterations fixed-point algorithm. Default: 50. tol Numeric, tolerance convergence. algorithm stops Frobenius norm difference successive estimates barycenter tolerance. Default: 1e-7. regularize_epsilon Numeric, small positive value regularizing input matrices intermediate results ensure positive definiteness. Default: 1e-6. verbose Logical, TRUE, prints iteration information. Default: FALSE. damping Numeric, damping factor update step. Default 0.5.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/bures_wasserstein_barycenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","text":"p x p SPD matrix representing Bures-Wasserstein barycenter.   Returns NULL computation fails inputs invalid.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/bures_wasserstein_barycenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Bures-Wasserstein Barycenter of SPD Matrices — bures_wasserstein_barycenter","text":"","code":"# S1 <- matrix(c(2,1,1,2), 2,2) # S2 <- matrix(c(3,0,0,3), 2,2) # S_list_bw <- list(S1, S2) # bw_mean <- bures_wasserstein_barycenter(S_list_bw, verbose = TRUE) # print(bw_mean)  # Weighted example # S3 <- matrix(c(1.5,0.5,0.5,1.5), 2,2) # bw_mean_weighted <- bures_wasserstein_barycenter(list(S1,S2,S3), weights=c(0.5,0.25,0.25)) # print(bw_mean_weighted)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/chunked_sparse_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute pairwise correlations in manageable chunks — chunked_sparse_cor","title":"Compute pairwise correlations in manageable chunks — chunked_sparse_cor","text":"Helper computes Pearson correlations columns `X_centered` blocks avoid allocating full `V_p  V_p` dense matrix. block contains `block_size` columns returns list correlation submatrices.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/chunked_sparse_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute pairwise correlations in manageable chunks — chunked_sparse_cor","text":"","code":"chunked_sparse_cor(X_centered, col_sds, block_size = 50L)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/chunked_sparse_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute pairwise correlations in manageable chunks — chunked_sparse_cor","text":"X_centered centered numeric matrix (`T_i` x `V_p`). col_sds Vector column standard deviations `X_centered`. block_size Number columns per block. Defaults 50.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/chunked_sparse_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute pairwise correlations in manageable chunks — chunked_sparse_cor","text":"list element contains: `indices`: integer vector column indices covered block. `corr`: matrix correlations (`length(indices)` x `V_p`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/coef.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients (mean aligned sketch) from a hatsa_projector object — coef.hatsa_projector","title":"Extract coefficients (mean aligned sketch) from a hatsa_projector object — coef.hatsa_projector","text":"Extract coefficients (mean aligned sketch) hatsa_projector object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/coef.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients (mean aligned sketch) from a hatsa_projector object — coef.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' coef(object, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/coef.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients (mean aligned sketch) from a hatsa_projector object — coef.hatsa_projector","text":"object hatsa_projector object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/coef.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract coefficients (mean aligned sketch) from a hatsa_projector object — coef.hatsa_projector","text":"mean aligned sketch matrix (v).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_activations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Task-Based Parcel Similarity Graph (W_task) from Activations — compute_W_task_from_activations","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Activations — compute_W_task_from_activations","text":"Calculates sparse, z-scored similarity graph parcels based activation profiles across different conditions task features.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_activations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Activations — compute_W_task_from_activations","text":"","code":"compute_W_task_from_activations(   activation_matrix,   parcel_names,   k_conn_task_pos,   k_conn_task_neg,   similarity_method = \"pearson\",   use_dtw = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_activations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Activations — compute_W_task_from_activations","text":"activation_matrix numeric matrix (`C x V_p`) `C` number conditions/features `V_p` number parcels. column represents activation profile parcel. parcel_names character vector length `V_p` specifying parcel names. k_conn_task_pos Non-negative integer. Number strongest positive connections retain per parcel sparsification. k_conn_task_neg Non-negative integer. Number strongest negative connections retain per parcel sparsification. similarity_method Character string function. Specifies method compute initial `V_p x V_p` similarity matrix `activation_matrix`. \"pearson\" (default) \"spearman\", `stats::cor` used. function, must take `activation_matrix` input return `V_p x V_p` numeric matrix. use_dtw Logical, defaults `FALSE`. (Placeholder, currently unused kept potential future compatibility signature consistency).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_activations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Activations — compute_W_task_from_activations","text":"sparse, symmetric `Matrix::dgCMatrix` size `V_p x V_p`   representing z-scored task-based similarity graph `W_task_i`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_encoding.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Task-Based Parcel Similarity Graph (W_task) from Encoding Weights — compute_W_task_from_encoding","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Encoding Weights — compute_W_task_from_encoding","text":"Calculates sparse, z-scored similarity graph parcels based encoding weight profiles set features.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_encoding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Encoding Weights — compute_W_task_from_encoding","text":"","code":"compute_W_task_from_encoding(   encoding_weights_matrix,   parcel_names,   k_conn_task_pos,   k_conn_task_neg,   similarity_method = \"pearson\" )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_encoding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Encoding Weights — compute_W_task_from_encoding","text":"encoding_weights_matrix numeric matrix (`V_p x N_features`) `V_p` number parcels `N_features` number encoding features. row represents encoding weight profile parcel. parcel_names character vector length `V_p` specifying parcel names. k_conn_task_pos Non-negative integer. Number strongest positive connections retain per parcel sparsification. k_conn_task_neg Non-negative integer. Number strongest negative connections retain per parcel sparsification. similarity_method Character string function. Specifies method compute initial `V_p x V_p` similarity matrix. \"pearson\" (default) \"spearman\", `stats::cor` used transposed input (compare rows/parcels). function, must take `encoding_weights_matrix` (V_p x N_features) input return `V_p x V_p` numeric matrix.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_W_task_from_encoding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Task-Based Parcel Similarity Graph (W_task) from Encoding Weights — compute_W_task_from_encoding","text":"sparse, symmetric `Matrix::dgCMatrix` size `V_p x V_p`   representing z-scored task-based similarity graph `W_task_i`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_anchor_template_recovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","title":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","text":"Evaluates well estimated group anchor template (`object$T_anchor_final` `hatsa_projector` object) matches true spectral basis anchor locations.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_anchor_template_recovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","text":"","code":"compute_anchor_template_recovery(   hatsa_object,   U_true,   anchor_indices_true,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_anchor_template_recovery.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","text":"hatsa_object fitted `hatsa_projector` object. U_true ground-truth spectral basis (matrix, Vp x k) parcels. anchor_indices_true numeric vector indices specifying rows `U_true` correspond anchor parcels. ... Additional arguments passed `vegan::procrustes`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_anchor_template_recovery.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","text":"list containing: correlation Pearson correlation vectorized aligned estimated     anchor template vectorized true anchor template. frobenius_norm_diff Frobenius norm difference     aligned estimated anchor template true anchor template. procrustes_result result `vegan::procrustes` call. T_anchor_aligned Procrustes-aligned estimated anchor template.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_anchor_template_recovery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Anchor Template (T_anchor_final) Recovery Metrics — compute_anchor_template_recovery","text":"","code":"# See core-hatsa-toy-example.Rmd for usage."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_eigenvalue_fidelity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","title":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","text":"Compares subject-specific eigenvalues HATSA (`Lambda_original_list`) true eigenvalues (e.g., toy data generator).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_eigenvalue_fidelity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","text":"","code":"compute_eigenvalue_fidelity(   hatsa_object,   true_eigenvalues_list,   k_to_compare = NULL )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_eigenvalue_fidelity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","text":"hatsa_object fitted `hatsa_projector` object, contains `Lambda_original_list` (list numeric vectors eigenvalues). true_eigenvalues_list list numeric vectors, vector contains true eigenvalues corresponding subject. single vector provided, assumed common true eigenvalues subjects. k_to_compare Integer NULL. number top eigenvalues compare. NULL (default), available eigenvalues compared (length shorter estimated true eigenvalue vectors subject).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_eigenvalue_fidelity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","text":"list lists, one subject. inner list contains: correlation Pearson correlation estimated true eigenvalues. mse Mean Squared Error estimated true eigenvalues. num_compared number eigenvalue pairs actually compared. Returns NULL subject inputs invalid subject.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_eigenvalue_fidelity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Eigenvalue Spectrum Fidelity Metrics — compute_eigenvalue_fidelity","text":"","code":"# See core-hatsa-toy-example.Rmd for usage."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_gev_spectrum_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","title":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","text":"Computes various diagnostic statistics vector Generalized Eigenvalues (GEV).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_gev_spectrum_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","text":"","code":"compute_gev_spectrum_diagnostics(Lambda_GEV, lambda_max_thresh)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_gev_spectrum_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","text":"Lambda_GEV numeric vector eigenvalues obtained GEV. lambda_max_thresh numeric threshold used categorize eigenvalues. Eigenvalues absolute value less considered 'retained' 'stable'.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_gev_spectrum_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","text":"list containing following diagnostic statistics:   \\itemize     \\itemn_eigenvalues: Total number eigenvalues.     \\itemmin_eigenvalue: Minimum eigenvalue.     \\itemmax_eigenvalue: Maximum eigenvalue.     \\itemmean_eigenvalue: Mean eigenvalues.     \\itemmedian_eigenvalue: Median eigenvalues.     \\itemsd_eigenvalue: Standard deviation eigenvalues.     \\itemn_below_thresh: Number eigenvalues absolute value < lambda_max_thresh.     \\itemprop_below_thresh: Proportion eigenvalues absolute value < lambda_max_thresh.     \\itemn_above_thresh: Number eigenvalues absolute value >= lambda_max_thresh.     \\itemprop_above_thresh: Proportion eigenvalues absolute value >= lambda_max_thresh.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_gev_spectrum_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute GEV Spectrum Diagnostics — compute_gev_spectrum_diagnostics","text":"","code":"Lambda_GEV_sample <- c(0.1, 0.5, 0.85, 0.95, 1.2)   compute_gev_spectrum_diagnostics(Lambda_GEV_sample, lambda_max_thresh = 0.8) #> $n_eigenvalues #> [1] 5 #>  #> $min_eigenvalue #> [1] 0.1 #>  #> $max_eigenvalue #> [1] 1.2 #>  #> $mean_eigenvalue #> [1] 0.72 #>  #> $median_eigenvalue #> [1] 0.85 #>  #> $sd_eigenvalue #> [1] 0.4280771 #>  #> $n_below_thresh #> [1] 2 #>  #> $prop_below_thresh #> [1] 0.4 #>  #> $n_above_thresh #> [1] 3 #>  #> $prop_above_thresh #> [1] 0.6 #>"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_correlation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Correlation Between Two Sparse Graphs — compute_graph_correlation","title":"Compute Correlation Between Two Sparse Graphs — compute_graph_correlation","text":"Calculates Spearman correlation edge weights two sparse graphs, considering union non-zero edges filling missing edges 0. upper triangle matrices considered.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_correlation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Correlation Between Two Sparse Graphs — compute_graph_correlation","text":"","code":"compute_graph_correlation(W_graph1, W_graph2, max_edges = 2e+06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_correlation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Correlation Between Two Sparse Graphs — compute_graph_correlation","text":"W_graph1 sparse, symmetric matrix (`Matrix::dgCMatrix`, `V_p x V_p`). Assumed z-scored non-zero entries. W_graph2 sparse, symmetric matrix (`Matrix::dgCMatrix`, `V_p x V_p`). Assumed z-scored non-zero entries. max_edges integer `Inf`. number unique edges union upper triangles exceeds `max_edges`, random sample `max_edges` edges used correlation calculation. Defaults 2,000,000.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_correlation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Correlation Between Two Sparse Graphs — compute_graph_correlation","text":"Spearman correlation coefficient (`rho`) edge weights   two graphs based union upper triangle edges. Returns `NA`   correlation computed (e.g., edges, zero variance).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_laplacian_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = I - α D⁻¹ W` — compute_graph_laplacian_sparse","title":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = I - α D⁻¹ W` — compute_graph_laplacian_sparse","text":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = - α D⁻¹ W`","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_laplacian_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = I - α D⁻¹ W` — compute_graph_laplacian_sparse","text":"","code":"compute_graph_laplacian_sparse(W_sparse, alpha = 0.93, degree_type = \"abs\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_laplacian_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = I - α D⁻¹ W` — compute_graph_laplacian_sparse","text":"W_sparse sparse, symmetric adjacency matrix (`Matrix::dgCMatrix`, `V_p x V_p`). Symmetry verified using Matrix::isSymmetric() (tolerance 1e-8); function stops error matrix symmetric. alpha Numeric, laziness parameter. Default 0.93. clamped `[epsilon, 1]` range outside `(0,1]`. degree_type Character string, calculate node degrees `W_sparse` negative values. One `\"abs\"` (default, sum absolute weights), `\"positive\"` (sum positive weights ), `\"signed\"` (sum raw weights). Documented clarity.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_graph_laplacian_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute sparse α-lazy random-walk normalized graph Laplacian `L = I - α D⁻¹ W` — compute_graph_laplacian_sparse","text":"sparse, symmetric graph Laplacian matrix (`Matrix::dgCMatrix`, `V_p x V_p`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_mds_distance_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Riemannian Distance Matrix — compute_mds_distance_matrix","title":"Compute Riemannian Distance Matrix — compute_mds_distance_matrix","text":"Wrapper around `riemannian_distance_matrix_spd` used `plot_mds_spd_subjects`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_mds_distance_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Riemannian Distance Matrix — compute_mds_distance_matrix","text":"","code":"compute_mds_distance_matrix(   projector_object,   spd_representation_type,   dist_mat_options = list(),   verbose = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_mds_distance_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Riemannian Distance Matrix — compute_mds_distance_matrix","text":"projector_object `hatsa_projector` `task_hatsa_projector`. spd_representation_type Character string indicating SPD representation use. dist_mat_options List additional arguments `riemannian_distance_matrix_spd`. verbose Logical controlling message output.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_mds_distance_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Riemannian Distance Matrix — compute_mds_distance_matrix","text":"numeric matrix `NULL` failure.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_rotation_recovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","title":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","text":"Assesses accurately subject-specific rotation matrices (`R_i`) estimated HATSA match true rotations.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_rotation_recovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","text":"","code":"compute_rotation_recovery(hatsa_object, R_true_list, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_rotation_recovery.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","text":"hatsa_object fitted `hatsa_projector` object, contains `R_final_list` (list estimated k x k rotation matrices). R_true_list list true k x k rotation matrices, corresponding subject `hatsa_object`. ... Additional arguments passed `misalign_deg` function.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_rotation_recovery.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","text":"numeric vector misalignment angles degrees, one   subject. Returns `NA` subjects either estimated true   rotation missing invalid comparison.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_rotation_recovery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Rotation Recovery (SO(k) Alignment) Metrics — compute_rotation_recovery","text":"","code":"# See core-hatsa-toy-example.Rmd for usage."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_spectral_sketch_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute spectral sketch `U_orig_i` using `PRIMME` or `base::eigen` — compute_spectral_sketch_sparse","title":"Compute spectral sketch `U_orig_i` using `PRIMME` or `base::eigen` — compute_spectral_sketch_sparse","text":"Computes `k` eigenvectors sparse graph Laplacian `L_conn_i_sparse` corresponding smallest, non-trivial eigenvalues. Eigenvectors eigenvalues numerically close zero discarded based dynamic tolerance.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_spectral_sketch_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute spectral sketch `U_orig_i` using `PRIMME` or `base::eigen` — compute_spectral_sketch_sparse","text":"","code":"compute_spectral_sketch_sparse(L_conn_i_sparse, k, eigenvalue_tol = 1e-08)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_spectral_sketch_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute spectral sketch `U_orig_i` using `PRIMME` or `base::eigen` — compute_spectral_sketch_sparse","text":"L_conn_i_sparse sparse graph Laplacian matrix (`Matrix::dgCMatrix`, `V_p x V_p`). Must symmetric. k integer, desired spectral rank. Must `k >= 0`. eigenvalue_tol Numeric floor used dynamically determining tolerance filtering near-zero eigenvalues. Defaults `1e-8`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_spectral_sketch_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute spectral sketch `U_orig_i` using `PRIMME` or `base::eigen` — compute_spectral_sketch_sparse","text":"list containing two elements:   - `vectors`: dense matrix `U_orig_i` (`V_p x k_actual`) eigenvectors.     `k_actual` may less `k` enough informative eigenvectors found.   - `values`: vector eigenvalues corresponding eigenvectors.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_subject_connectivity_graph_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","title":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","text":"Calculates sparse connectivity graph single subject. Steps: 1. Compute pairwise Pearson correlations using memory-efficient    cross-product approach avoids constructing dense `V_p`  `V_p` matrix. 2. Identify mask zero-variance parcels. 3. Sparsify: parcel, identify indices `k_conn_pos` strongest    positive `k_conn_neg` strongest negative correlations, using partial sort.    Exclude zero-variance parcels selection candidates.    Construct directed sparse graph `W_dir` . 4. Symmetrize `W_dir` using `W_sym_raw = (W_dir + t(W_dir)) / 2`, `drop0`. 5. Ensure strict symmetry z-scoring: `W_symmetric = Matrix::forceSymmetric(W_sym_raw, uplo=\"U\")`. 6. Z-score non-zero edge weights `W_symmetric` (assumes `zscore_nonzero_sparse` stable).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_subject_connectivity_graph_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","text":"","code":"compute_subject_connectivity_graph_sparse(   X_subject,   parcel_names,   k_conn_pos,   k_conn_neg,   use_dtw = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_subject_connectivity_graph_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","text":"X_subject numeric matrix time-series data one subject (`T_i` time points x `V_p` parcels). parcel_names character vector parcel names. k_conn_pos integer, number positive connections retain per node. k_conn_neg integer, number negative connections retain per node. use_dtw Logical, defaults `FALSE`. (Placeholder).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_subject_connectivity_graph_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","text":"sparse symmetric `Matrix::dgCMatrix` size `V_p x V_p`   representing z-scored connectivity graph `W_conn_i`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_subject_connectivity_graph_sparse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute subject-specific sparse connectivity graph `W_conn_i` — compute_subject_connectivity_graph_sparse","text":"`X_subject` must contain least two rows (time points).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_v_recovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","title":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","text":"Evaluates well estimated group-level spectral template (`object$v` `hatsa_projector` object) matches true ground-truth spectral basis.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_v_recovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","text":"","code":"compute_v_recovery(hatsa_object, U_true, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_v_recovery.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","text":"hatsa_object fitted `hatsa_projector` object. U_true ground-truth spectral basis (matrix, e.g., Vp x k). ... Additional arguments passed `vegan::procrustes`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_v_recovery.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","text":"list containing: correlation Pearson correlation vectorized aligned estimated     template vectorized true template. frobenius_norm_diff Frobenius norm difference     aligned estimated template true template. procrustes_result result `vegan::procrustes` call. v_aligned Procrustes-aligned estimated group template.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_v_recovery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Group Template (v) Recovery Metrics — compute_v_recovery","text":"","code":"# See core-hatsa-toy-example.Rmd for usage."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_voxel_basis_nystrom.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","title":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","text":"Internal helper function compute Nyström extension basis projecting voxel-level data parcel-defined spectral space. function uses k-nearest neighbors approach Gaussian kernel create affinity matrix voxels parcels, applies Nyström formula.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_voxel_basis_nystrom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","text":"","code":"compute_voxel_basis_nystrom(   voxel_coords,   parcel_coords,   U_orig_parcel,   Lambda_orig_parcel,   n_nearest_parcels = 10,   kernel_sigma = 5,   row_normalize_W = TRUE,   eigenvalue_floor = 1e-08,   W_vox_parc = NULL,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_voxel_basis_nystrom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","text":"voxel_coords numeric matrix (V_v x 3) voxel coordinates. parcel_coords numeric matrix (V_p x 3) parcel centroid coordinates. U_orig_parcel numeric matrix (V_p x k) subject's original parcel-level eigenvectors (spectral sketch). Lambda_orig_parcel numeric vector length k, representing subject's original parcel-level eigenvalues. Values positive. n_nearest_parcels integer, number nearest parcels (k_nn) consider voxel constructing affinity matrix ** `W_vox_parc` provided. Must least 1 exceed number parcels (`nrow(parcel_coords)`). Ignored `W_vox_parc` provided. kernel_sigma numeric scalar, bandwidth (sigma) Gaussian kernel, string \\\"auto\\\". Used ** `W_vox_parc` provided. \\\"auto\\\", sigma estimated `median(dist_to_1st_nn_parcel) / sqrt(2)`, `dist_to_1st_nn_parcel` Euclidean distances voxel closest parcel centroid. fallback value (e.g., 1.0) used auto-estimation possible. Defaults 5.0. Ignored `W_vox_parc` provided. row_normalize_W logical. Controls whether effective affinity matrix (`W_vox_parc`, either computed internally provided) row-normalized computing Phi_voxel. core HATSA algorithm uses alpha-lazy random-walk normalized Laplacian (`L_rw_lazy`), consistency, standard Nyström extension involves row-normalizing voxel-parcel affinities. Defaults `TRUE`. eigenvalue_floor small positive numeric value floor near-zero eigenvalues inversion. Defaults 1e-8. W_vox_parc Optional. pre-computed sparse matrix (dgCMatrix, V_v x V_p) representing voxel--parcel affinities weights. provided, function skip internal k-NN search Gaussian kernel calculation use matrix directly. must dimensions V_v x V_p. Default `NULL`, triggering internal calculation. ... Additional arguments (currently unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_voxel_basis_nystrom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","text":"dense numeric matrix Phi_voxel (V_v x k), representing   Nyström basis voxels. Note: large numbers voxels (V_v) /  components (k), matrix can memory-intensive (e.g., V_v=400k, k=50   using 8-byte doubles ~153MB).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/compute_voxel_basis_nystrom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Nyström Voxel Basis (Phi_voxel) — compute_voxel_basis_nystrom","text":"","code":"# V_p <- 100; V_v <- 500; k <- 10; n_nearest <- 5; sigma <- 5 # p_coords <- matrix(rnorm(V_p*3), V_p, 3) # v_coords <- matrix(rnorm(V_v*3), V_v, 3) # U_p <- matrix(rnorm(V_p*k), V_p, k) # L_p <- runif(k, 0.1, 1) # if (requireNamespace(\"RANN\", quietly = TRUE) &&  #     requireNamespace(\"Matrix\", quietly = TRUE)) { #   Phi_v <- compute_voxel_basis_nystrom(v_coords, p_coords, U_p, L_p,  #                                        n_nearest, sigma) #   # dim(Phi_v) # Should be V_v x k # }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/configure_task_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure Task Parameters — configure_task_params","title":"Configure Task Parameters — configure_task_params","text":"Configure Task Parameters","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/configure_task_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure Task Parameters — configure_task_params","text":"","code":"configure_task_params(method, base_config, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/discover_optimal_anchors.html","id":null,"dir":"Reference","previous_headings":"","what":"Discover Optimal Anchors from Training Data — discover_optimal_anchors","title":"Discover Optimal Anchors from Training Data — discover_optimal_anchors","text":"Comprehensive anchor discovery pipeline evaluates multiple selection strategies quality metrics training dataset.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/discover_optimal_anchors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discover Optimal Anchors from Training Data — discover_optimal_anchors","text":"","code":"discover_optimal_anchors(   training_data,   n_components = 20,   n_anchors = 100,   n_pilot = min(10, length(training_data)),   methods = c(\"mra\", \"coverage\", \"stability\"),   evaluate_stability = TRUE,   save_results = TRUE,   output_dir = \"hatsa_anchors\",   verbose = TRUE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/discover_optimal_anchors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discover Optimal Anchors from Training Data — discover_optimal_anchors","text":"training_data List training subject data matrices n_components Number spectral components use n_anchors Target number anchors n_pilot Number pilot subjects initial selection (default: 10) methods Character vector selection methods try evaluate_stability Whether evaluate anchor stability save_results Whether save results file output_dir Directory saving results verbose Print progress messages","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/discover_optimal_anchors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discover Optimal Anchors from Training Data — discover_optimal_anchors","text":"anchor_selection_result object containing:   - selected_anchors: Final selected anchor indices   - quality_metrics: Comprehensive quality assessment   - selection_report: Detailed report selection process","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-compute_cov_spectral_coeffs.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Covariance of Aligned Spectral Coefficients — .compute_cov_spectral_coeffs","title":"Compute Covariance of Aligned Spectral Coefficients — .compute_cov_spectral_coeffs","text":"given subject's aligned spectral sketch `U_aligned_i` (V_p x k), function computes `k x k` covariance matrix coefficients across V_p parcels.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-compute_cov_spectral_coeffs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Covariance of Aligned Spectral Coefficients — .compute_cov_spectral_coeffs","text":"","code":".compute_cov_spectral_coeffs(U_aligned_subject)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-compute_cov_spectral_coeffs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Covariance of Aligned Spectral Coefficients — .compute_cov_spectral_coeffs","text":"U_aligned_subject numeric matrix (V_p x k) aligned spectral coefficients.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-compute_cov_spectral_coeffs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Covariance of Aligned Spectral Coefficients — .compute_cov_spectral_coeffs","text":"`k x k` covariance matrix. Returns matrix NAs V_p <= 1 k = 0, input NULL.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-densify_symmetrize_regularize.html","id":null,"dir":"Reference","previous_headings":"","what":"Densify, symmetrize and regularize a connectivity matrix — .densify_symmetrize_regularize","title":"Densify, symmetrize and regularize a connectivity matrix — .densify_symmetrize_regularize","text":"Helper used `get_spd_representations()` convert sparse connectivity matrices dense form needed, enforce symmetry, apply SPD regularization.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-densify_symmetrize_regularize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Densify, symmetrize and regularize a connectivity matrix — .densify_symmetrize_regularize","text":"","code":".densify_symmetrize_regularize(M, epsilon)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-densify_symmetrize_regularize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Densify, symmetrize and regularize a connectivity matrix — .densify_symmetrize_regularize","text":"M numeric matrix `Matrix` object representing connectivity matrix. epsilon Numeric scalar used SPD regularization.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-densify_symmetrize_regularize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Densify, symmetrize and regularize a connectivity matrix — .densify_symmetrize_regularize","text":"dense symmetric positive-definite matrix, `NULL` `M` `NULL`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-so_logm_closed_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","title":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","text":"Calculates Fréchet mean (geometric mean) list k x k rotation matrices. Fréchet mean rotation matrix R_bar minimizes sum squared geodesic distances rotation matrices list: R_bar = argmin_R sum_i d(R, R_i)^2. implementation uses iterative algorithm involving logarithmic exponential maps (k).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-so_logm_closed_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","text":"","code":".so_logm_closed_form(R)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-so_logm_closed_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","text":"R_list list k x k matrices, expected rotation matrices ((k) O(k)). function attempts work matrices close (k). k_dim Integer, dimension rotation matrices (e.g., 3 (3)). NULL (default), inferred first valid matrix `R_list`. max_iter Integer, maximum number iterations algorithm (default: 50). tol Numeric, tolerance convergence. algorithm stops Frobenius norm mean tangent vector tolerance (default: 1e-7). initial_mean Optional. k x k matrix use initial estimate mean. NULL, first valid matrix `R_list` used, identity matrix none valid. project_to_SOk Logical. TRUE (default), update, new mean estimate projected closest matrix (k) using SVD. helps maintain numerical stability ensures result indeed (k).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-so_logm_closed_form.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","text":"k x k matrix representing Fréchet mean input rotation matrices.   Returns identity matrix appropriate dimension `R_list` empty, contains valid   matrices, `k_dim` determined.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-so_logm_closed_form.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Fréchet Mean of Rotation Matrices on SO(k) — .so_logm_closed_form","text":"","code":"# Example for SO(3) if (requireNamespace(\"expm\", quietly = TRUE)) {   R1 <- matrix(c(1,0,0, 0,cos(0.1),-sin(0.1), 0,sin(0.1),cos(0.1)), 3, 3)   R2 <- matrix(c(cos(0.2),-sin(0.2),0, sin(0.2),cos(0.2),0, 0,0,1), 3, 3)   R_list_so3 <- list(R1, R2)   # frechet_mean_so_k(R_list_so3) # k_dim inferred   # frechet_mean_so_k(R_list_so3, k_dim = 3) }  # Example for SO(2) if (requireNamespace(\"expm\", quietly = TRUE)) {   theta1 <- pi/4   R1_so2 <- matrix(c(cos(theta1), -sin(theta1), sin(theta1), cos(theta1)), 2, 2)   theta2 <- pi/3   R2_so2 <- matrix(c(cos(theta2), -sin(theta2), sin(theta2), cos(theta2)), 2, 2)   # frechet_mean_so_k(list(R1_so2, R2_so2)) }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-validate_coordinate_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal helper to validate coordinate system inputs — .validate_coordinate_inputs","title":"Internal helper to validate coordinate system inputs — .validate_coordinate_inputs","text":"Checks gross inconsistencies voxel parcel coordinates, vastly different ranges potential scale issues, comparing bounding boxes.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-validate_coordinate_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal helper to validate coordinate system inputs — .validate_coordinate_inputs","text":"","code":".validate_coordinate_inputs(   voxel_coords,   parcel_coords,   scale_threshold = 10,   absolute_range_threshold = 50 )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/dot-validate_coordinate_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal helper to validate coordinate system inputs — .validate_coordinate_inputs","text":"voxel_coords Matrix voxel coordinates (V_v x 3). parcel_coords Matrix parcel coordinates (V_p x 3). scale_threshold Factor coordinate spans can differ warning. absolute_range_threshold Warn ranges overlap separated .","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/estimate_noise_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate noise level from data — estimate_noise_level","title":"Estimate noise level from data — estimate_noise_level","text":"Estimate noise level data","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/estimate_noise_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate noise level from data — estimate_noise_level","text":"","code":"estimate_noise_level(X)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_airm.html","id":null,"dir":"Reference","previous_headings":"","what":"Exp Map for SPD Matrices (AIRM Metric) — expmap_spd_airm","title":"Exp Map for SPD Matrices (AIRM Metric) — expmap_spd_airm","text":"Maps tangent vector V (symmetric matrix) tangent space SPD matrix S1 back SPD manifold using AIRM. Result `S1^(1/2)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_airm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exp Map for SPD Matrices (AIRM Metric) — expmap_spd_airm","text":"","code":"expmap_spd_airm(S1, V_at_S1, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_airm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exp Map for SPD Matrices (AIRM Metric) — expmap_spd_airm","text":"S1 SPD matrix (point manifold). V_at_S1 Symmetric matrix (tangent vector S1). regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_airm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exp Map for SPD Matrices (AIRM Metric) — expmap_spd_airm","text":"SPD matrix manifold.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_logeuclidean.html","id":null,"dir":"Reference","previous_headings":"","what":"Exp Map for SPD Matrices (Log-Euclidean Metric) — expmap_spd_logeuclidean","title":"Exp Map for SPD Matrices (Log-Euclidean Metric) — expmap_spd_logeuclidean","text":"Maps tangent vector V (symmetric matrix) tangent space SPD matrix S1 back SPD manifold using Log-Euclidean metric. Result `expm(logm(S1) + V)`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_logeuclidean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exp Map for SPD Matrices (Log-Euclidean Metric) — expmap_spd_logeuclidean","text":"","code":"expmap_spd_logeuclidean(S1, V_at_S1, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_logeuclidean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exp Map for SPD Matrices (Log-Euclidean Metric) — expmap_spd_logeuclidean","text":"S1 SPD matrix (point manifold tangent space anchored). V_at_S1 Symmetric matrix (tangent vector S1). regularize_epsilon Epsilon regularization S1. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/expmap_spd_logeuclidean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exp Map for SPD Matrices (Log-Euclidean Metric) — expmap_spd_logeuclidean","text":"SPD matrix manifold.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_so_karcher.html","id":null,"dir":"Reference","previous_headings":"","what":"Full Karcher Mean on SO(k) — frechet_mean_so_karcher","title":"Full Karcher Mean on SO(k) — frechet_mean_so_karcher","text":"Iteratively computes Karcher mean list rotation matrices.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_so_karcher.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full Karcher Mean on SO(k) — frechet_mean_so_karcher","text":"","code":"frechet_mean_so_karcher(Rlist, R_init = NULL, tol = 1e-10, maxit = 100L)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_so_karcher.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Full Karcher Mean on SO(k) — frechet_mean_so_karcher","text":"Rlist list k x k rotation matrices. R_init Optional initial estimate. Defaults chordal mean. tol Convergence tolerance. Default 1e-10. maxit Maximum number iterations. Default 100.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_so_karcher.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Full Karcher Mean on SO(k) — frechet_mean_so_karcher","text":"k x k matrix giving Karcher mean.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Fréchet Mean of SPD Matrices — frechet_mean_spd","title":"Fréchet Mean of SPD Matrices — frechet_mean_spd","text":"Computes Fréchet mean (Karcher mean) list Symmetric Positive-Definite (SPD) matrices. function can use either Affine-Invariant Riemannian Metric (AIRM) via `shapes` package (available `metric=\"airm\"`), iterative algorithm based Log-Euclidean metric (`metric=\"logeuclidean\"`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fréchet Mean of SPD Matrices — frechet_mean_spd","text":"","code":"frechet_mean_spd(   S_list,   metric = c(\"logeuclidean\", \"airm\"),   regularize_epsilon = 1e-06,   max_iter = 50,   tol = 1e-05,   step_size = 0.5,   init_method = c(\"euclidean\", \"first\"),   verbose = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fréchet Mean of SPD Matrices — frechet_mean_spd","text":"S_list list SPD matrices. metric Character string, either `\"logeuclidean\"` (default) `\"airm\"`. regularize_epsilon Epsilon regularization. Default 1e-6. max_iter Maximum number iterations Log-Euclidean algorithm. Default 50. tol Tolerance convergence Log-Euclidean algorithm (Frobenius norm mean tangent vector). Default 1e-5. step_size Step size gradient descent Log-Euclidean. Default 0.5. init_method Log-Euclidean, method initialize mean: `\"euclidean\"` (Euclidean mean matrices) `\"first\"` (first matrix list). Default `\"euclidean\"`. verbose Logical, TRUE, prints iteration info Log-Euclidean. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/frechet_mean_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fréchet Mean of SPD Matrices — frechet_mean_spd","text":"Fréchet mean (SPD matrix).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_anchor_sketches.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Anchor Sketches — get_anchor_sketches","title":"Get Anchor Sketches — get_anchor_sketches","text":"Extract subject-specific anchor sketch matrices (original aligned). Implements HMET-003.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_anchor_sketches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Anchor Sketches — get_anchor_sketches","text":"","code":"get_anchor_sketches(   object,   type = c(\"original\", \"aligned\"),   subject_idx = NULL,   cache_in_object = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_anchor_sketches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Anchor Sketches — get_anchor_sketches","text":"object hatsa_projector object type Either \"original\" \"aligned\" subject_idx Optional subject index (NULL subjects) cache_in_object Whether cache results object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_anchor_sketches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Anchor Sketches — get_anchor_sketches","text":"List anchor sketch matrices single matrix subject_idx specified","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_condition_numbers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Condition Numbers — get_condition_numbers","title":"Get Condition Numbers — get_condition_numbers","text":"Compute condition numbers various matrices HATSA results. Implements HMET-006 related metrics.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_condition_numbers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Condition Numbers — get_condition_numbers","text":"","code":"get_condition_numbers(   object,   what = c(\"T_anchor_final\", \"anchor_sketches\", \"all\") )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_condition_numbers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Condition Numbers — get_condition_numbers","text":"object hatsa_projector object condition number(s) compute","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_condition_numbers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Condition Numbers — get_condition_numbers","text":"Named list condition numbers","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_spd_representations.html","id":null,"dir":"Reference","previous_headings":"","what":"Get SPD Matrix Representations from a HATSA Projector Object — get_spd_representations","title":"Get SPD Matrix Representations from a HATSA Projector Object — get_spd_representations","text":"Extracts computes various types Symmetric Positive-Definite (SPD) matrix representations subjects `hatsa_projector` object.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_spd_representations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get SPD Matrix Representations from a HATSA Projector Object — get_spd_representations","text":"","code":"get_spd_representations(object, ...)  # S3 method for class 'hatsa_projector' get_spd_representations(   object,   type = c(\"cov_coeffs\", \"fc_conn\"),   subject_idx = NULL,   regularize_epsilon = 1e-06,   subject_data_list_for_fc = NULL,   k_conn_params_for_fc = list(),   ... )  # S3 method for class 'task_hatsa_projector' get_spd_representations(   object,   type = c(\"cov_coeffs\", \"fc_conn\", \"fc_task\", \"fc_hybrid\"),   subject_idx = NULL,   regularize_epsilon = 1e-06,   subject_data_list_for_fc = NULL,   k_conn_params_for_fc = list(),   lambda_blend_for_hybrid = NULL,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_spd_representations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get SPD Matrix Representations from a HATSA Projector Object — get_spd_representations","text":"object `hatsa_projector` `task_hatsa_projector` object. ... Additional arguments, potentially passed specific computation functions. type Character string indicating type SPD representation use. Currently supported `hatsa_projector`: `\"cov_coeffs\"` (covariance aligned spectral coefficients). types like `\"fc_conn\"` might added supported specific methods. subject_idx Optional integer vector integers. provided, returns SPD matrices subjects. NULL (default), subjects. regularize_epsilon Small positive value SPD regularization. Default RGEOM-001. subject_data_list_for_fc Optional list subject time-series matrices (T_i x V_p), needed `type = \"fc_conn\"`. k_conn_params_for_fc List parameters `compute_subject_connectivity_graph_sparse`, e.g., `list(k_conn_pos = 10, k_conn_neg = 10, zscore_type = \"abs\", ...)`. Needed `type = \"fc_conn\"`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_spd_representations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get SPD Matrix Representations from a HATSA Projector Object — get_spd_representations","text":"`subject_idx` length 1, single SPD matrix returned.   Otherwise list matrices returned `NULL` subjects whose SPD   representation computed.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_tangent_space_coords.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Subject SPD Representations to a Common Tangent Space — get_tangent_space_coords","title":"Project Subject SPD Representations to a Common Tangent Space — get_tangent_space_coords","text":"Computes Fréchet mean specified SPD representations group subjects projects subject's SPD matrix tangent space anchored mean. allows applying standard Euclidean multivariate analyses Riemannian data.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_tangent_space_coords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Subject SPD Representations to a Common Tangent Space — get_tangent_space_coords","text":"","code":"get_tangent_space_coords(object, ...)  # S3 method for class 'hatsa_projector' get_tangent_space_coords(   object,   type = \"cov_coeffs\",   tangent_metric = c(\"logeuclidean\", \"airm\"),   subject_data_list = NULL,   k_conn_params = NULL,   spd_regularize_epsilon = 1e-06,   mean_options = list(),   verbose = FALSE,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_tangent_space_coords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Subject SPD Representations to a Common Tangent Space — get_tangent_space_coords","text":"object `hatsa_projector` `task_hatsa_projector` object. ... Additional arguments passed `get_spd_representations` `frechet_mean_spd`. type Character string indicating type SPD representation use (e.g., `\"cov_coeffs\"`). Passed `get_spd_representations`. tangent_metric Character string, `\"logeuclidean\"` (default) `\"airm\"`, specifying metric's log map use projection. also influences metric Fréchet mean computation overridden `mean_options`. subject_data_list Optional. Passed `get_spd_representations`. k_conn_params Optional. Passed `get_spd_representations`. spd_regularize_epsilon Epsilon regularizing SPD matrices. mean_options list options `frechet_mean_spd` (e.g., `max_iter`, `tol`). `metric` argument within list override `tangent_metric` mean computation step provided. verbose Logical, controls verbosity.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/get_tangent_space_coords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Subject SPD Representations to a Common Tangent Space — get_tangent_space_coords","text":"list containing:   - `tangent_vectors`: list symmetric matrices (tangent vectors), one per valid subject.                      Names correspond subject original indices.   - `mean_spd_matrix`: Fréchet mean SPD matrix used tangent point.   - `metric_used`: metric used log map (`\"logeuclidean\"` `\"airm\"`).   - `num_valid_subjects`: Number subjects tangent vectors computed.   - `original_num_subjects`: Total number subjects input object.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grapes-or-or-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Null-safe or operator — %||%","title":"Null-safe or operator — %||%","text":"Returns x NULL, otherwise y.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grapes-or-or-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Null-safe or operator — %||%","text":"","code":"x %||% y  x %||% y"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grapes-or-or-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Null-safe or operator — %||%","text":"x, y Values compare.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grassmann_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Grassmann Distance between Subspaces — grassmann_distance","title":"Grassmann Distance between Subspaces — grassmann_distance","text":"Computes Grassmann distance two k-dimensional subspaces R^p, represented orthonormal basis matrices U V (p x k). distance `sqrt(sum(theta_i^2))`, `theta_i` principal angles subspaces. Principal angles `theta_i = acos(s_i)`, `s_i` singular values `U^T V`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grassmann_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grassmann Distance between Subspaces — grassmann_distance","text":"","code":"grassmann_distance(U, V, tol = 1e-06, sv_floor = 1e-07)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grassmann_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grassmann Distance between Subspaces — grassmann_distance","text":"U numeric matrix (p x k) orthonormal columns. V numeric matrix (p x k) orthonormal columns. tol Tolerance checking orthonormality. Default 1e-6. sv_floor Smallest value singular values acos avoid `acos(>1)` due numerical precision. Values clamped `[-1+sv_floor, 1-sv_floor]`. Default 1e-7.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grassmann_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grassmann Distance between Subspaces — grassmann_distance","text":"Grassmann distance (non-negative scalar).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/grassmann_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grassmann Distance between Subspaces — grassmann_distance","text":"","code":"# Example from P. Edelman, T. A. Arias, and A. S. Edelman. \"Geometry of algorithms # with orthogonality constraints.\" SIAM Journal on Matrix Analysis and Applications, 1998. p <- 3; k <- 2 U <- qr.Q(qr(matrix(rnorm(p*k), p, k))) V <- qr.Q(qr(matrix(rnorm(p*k), p, k))) # grassmann_distance(U, V)  # Identical subspaces # grassmann_distance(U, U) # Should be 0  # Orthogonal subspaces (if k <= p/2) if (k <= p/2) {   # V_ortho <- qr.Q(qr(matrix(rnorm(p*k), p, k)), complete=TRUE)[, (k+1):(2*k), drop=FALSE]   # if (ncol(V_ortho) == k) grassmann_distance(U, V_ortho) # Should be sqrt(k * (pi/2)^2) }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-accessors.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience Accessors for HATSA Results — hatsa-accessors","title":"Convenience Accessors for HATSA Results — hatsa-accessors","text":"Functions extract commonly needed components HATSA results user-friendly format.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-accessors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience Accessors for HATSA Results — hatsa-accessors","text":"","code":"get_aligned_data(x, subject = \"all\")  get_template(x)  get_rotations(x, subject = \"all\")  get_anchor_indices(x)  get_quality_metrics(x)  get_original_basis(x, subject = \"all\")  get_eigenvalues(x, subject = \"all\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-accessors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience Accessors for HATSA Results — hatsa-accessors","text":"x hatsa_projector task_hatsa_projector object subject Optional subject index \"\" ... Additional arguments","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-accessors.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Convenience Accessors for HATSA Results — hatsa-accessors","text":"get_aligned_data(): Get aligned data one subjects get_template(): Get group template (anchor alignment) get_rotations(): Get rotation matrices get_anchor_indices(): Get anchor indices used get_quality_metrics(): Get alignment quality metrics get_original_basis(): Get original (unaligned) basis functions get_eigenvalues(): Get eigenvalues spectral decomposition","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-package.html","id":null,"dir":"Reference","previous_headings":"","what":"hatsa: Hyperalignment via Task-informed Shared Analysis — hatsa-package","title":"hatsa: Hyperalignment via Task-informed Shared Analysis — hatsa-package","text":"Implements advanced hyperalignment methods functional neuroimaging data task-informed features. Provides sparse graph-based alignment functional connectivity patterns across subjects using spectral decomposition Procrustes alignment. Includes extensions task-informed alignment, Riemannian geometry operations SPD manifolds, voxel-level projection via Nyström extension. `hatsa` package implements Core HATSA (Hybrid Anchor-based Time-Series Alignment) algorithm. algorithm designed align functional connectivity patterns, represented spectral sketches derived graph Laplacians, across multiple subjects. leverages anchor parcels Generalized Procrustes Analysis robust alignment, employing sparse matrix operations computational efficiency.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-package.html","id":"core-hatsa-algorithm","dir":"Reference","previous_headings":"","what":"Core HATSA Algorithm","title":"hatsa: Hyperalignment via Task-informed Shared Analysis — hatsa-package","text":"primary function run_hatsa_core. processes subject-specific time-series data alignment parameters produce: Original spectral sketches subject. Aligned spectral sketches subject. corresponding rotation matrices ((k)) used alignment. algorithm follows three main stages: 1.  **Initial Spectral Sketching (per subject):** correlation matrix computed time-series. graph sparsified based strongest positive/negative             connections per parcel. sparsified graph symmetrized using weighted averaging scheme. Non-zero edge weights symmetrized graph z-scored,             ensuring symmetry preserved. sparse graph Laplacian (`L = D - W`) constructed. `k` eigenvectors corresponding smallest, non-zero             eigenvalues `L` form subject's original spectral sketch.             Eigenvectors eigenvalues numerically close zero discarded.             step uses efficient methods sparse matrices. 2.  **Iterative Refinement (Generalized Procrustes Analysis - GPA):** Rows corresponding pre-defined anchor parcels extracted             subject's original spectral sketch. group anchor template initialized (typically mean             subjects' anchor sketches). Iteratively: Subject-specific orthogonal rotation matrices (`R_i  (k)`)                     computed best align subject's anchor sketch                     current group template (Orthogonal Procrustes Problem). group anchor template updated mean                     subjects' rotated anchor sketches. 3.  **Apply Final Rotations:** final rotation matrices GPA applied             subject's full original spectral sketch obtain aligned             spectral sketches.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"hatsa: Hyperalignment via Task-informed Shared Analysis — hatsa-package","text":"Maintainer: Brad Buchsbaum brad.buchsbaum@gmail.com","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":null,"dir":"Reference","previous_headings":"","what":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"Guide avoiding common issues using HATSA.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":"pitfall-too-many-components","dir":"Reference","previous_headings":"","what":"Pitfall 1 - Too Many Components","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"Using many components relative data size can lead overfitting. Solution: Use hatsa_suggest() keep components < 10","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":"pitfall-mismatched-dimensions","dir":"Reference","previous_headings":"","what":"Pitfall 2 - Mismatched Dimensions","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"subjects must number voxels (spatial alignment). Solution: Ensure subjects space/parcellation.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":"pitfall-including-bad-subjects","dir":"Reference","previous_headings":"","what":"Pitfall 3 - Including Bad Subjects","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"Subjects excessive motion artifacts can degrade alignment. Solution: Pre-screen subjects exclude outliers.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":"pitfall-wrong-preprocessing","dir":"Reference","previous_headings":"","what":"Pitfall 4 - Wrong Preprocessing","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"HATSA expects centered data (zero mean per voxel). Solution: Always scale/center data HATSA.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-pitfalls.html","id":"pitfall-ignoring-convergence-warnings","dir":"Reference","previous_headings":"","what":"Pitfall 5 - Ignoring Convergence Warnings","title":"Common HATSA Pitfalls and Solutions — hatsa-pitfalls","text":"Warnings convergence indicate potential issues. Solution: Check data quality try different parameters.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-quality-metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional Quality Metrics for HATSA — hatsa-quality-metrics","title":"Additional Quality Metrics for HATSA — hatsa-quality-metrics","text":"Functions extract compute additional quality metrics HATSA results, implementing remaining tickets HMET series.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":null,"dir":"Reference","previous_headings":"","what":"HATSA Workflow Examples — hatsa-workflows","title":"HATSA Workflow Examples — hatsa-workflows","text":"documentation provides comprehensive examples common HATSA workflows, basic alignment advanced task-informed analyses.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"basic-workflow","dir":"Reference","previous_headings":"","what":"Basic Workflow","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# Load your data (list of subject matrices) data <- load_fmri_data()  # Returns list of time × voxel matrices  # Get parameter suggestions params <- hatsa_suggest(data)  # Run basic HATSA result <- hatsa(data, components = params$components)  # Extract aligned data aligned_data <- get_aligned_data(result) template <- get_template(result)  # Check quality hatsa_summary(result) plot_hatsa(result, type = \"eigenvalues\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"task-informed-workflow","dir":"Reference","previous_headings":"","what":"Task-Informed Workflow","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# Load task design matrices task_data <- load_task_designs()  # List of time × condition matrices  # Automatic method selection result <- hatsa_task(data, task_data, method = \"auto\")  # Or choose specific method result <- hatsa_task(data, task_data,                      method = \"blend\",                      lambda_blend = 0.2)  # Analyze task-specific alignment task_metrics <- get_task_alignment_metrics(result)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"advanced-anchor-selection","dir":"Reference","previous_headings":"","what":"Advanced Anchor Selection","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# Manual anchor selection based on ROI roi_indices <- get_roi_voxels(\"visual_cortex\") result <- hatsa(data, anchors = roi_indices)  # Multi-resolution anchor selection anchors <- select_anchors_mra(   U_list = preliminary_decomposition,   n_anchors = 100,   n_resolutions = 5 ) result <- hatsa(data, anchors = anchors)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"preprocessing-integration","dir":"Reference","previous_headings":"","what":"Preprocessing Integration","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# HATSA works best with preprocessed data data_clean <- lapply(data, function(X) {   X <- scale(X)  # Z-score time series   X[is.na(X)] <- 0  # Handle missing data   X })  # Run with custom preprocessing result <- hatsa(data_clean, preset = \"accurate\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"group-analysis","dir":"Reference","previous_headings":"","what":"Group Analysis","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# Align multiple groups separately result_controls <- hatsa(data[control_idx]) result_patients <- hatsa(data[patient_idx])  # Compare alignment quality compare_alignments(result_controls, result_patients)  # Project new subjects to existing space new_aligned <- predict(result_controls, newdata_list = new_subjects)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa-workflows.html","id":"performance-optimization","dir":"Reference","previous_headings":"","what":"Performance Optimization","title":"HATSA Workflow Examples — hatsa-workflows","text":"","code":"# For large datasets, use fast preset result <- hatsa(big_data, preset = \"fast\")  # For parallel processing (if available) options(hatsa.parallel = TRUE) options(hatsa.cores = 4) result <- hatsa(data)  # For very high-dimensional data # First reduce dimensions data_reduced <- lapply(data, function(X) {   svd_X <- svd(X, nu = 100, nv = 100)   svd_X$u  }) result <- hatsa(data_reduced)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple HATSA Interface — hatsa","title":"Simple HATSA Interface — hatsa","text":"streamlined interface HATSA sensible defaults automatic parameter selection.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple HATSA Interface — hatsa","text":"","code":"hatsa(   data,   anchors = \"auto\",   components = 20,   preset = c(\"default\", \"fast\", \"accurate\"),   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple HATSA Interface — hatsa","text":"data List subject data matrices (time × voxels) anchors Either \"auto\" automatic selection, vector anchor indices components Number spectral components (default: 20) preset Configuration preset: \"default\", \"fast\", \"accurate\" ... Additional parameters passed run_hatsa_core","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple HATSA Interface — hatsa","text":"hatsa_projector object convenience methods","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple HATSA Interface — hatsa","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage result <- hatsa(subject_data)  # With more components result <- hatsa(subject_data, components = 30)  # Fast mode for exploration result <- hatsa(subject_data, preset = \"fast\") } # }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_preset.html","id":null,"dir":"Reference","previous_headings":"","what":"HATSA Configuration Presets — hatsa_preset","title":"HATSA Configuration Presets — hatsa_preset","text":"HATSA Configuration Presets","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_preset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HATSA Configuration Presets — hatsa_preset","text":"","code":"hatsa_preset(name)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"HATSA Projector Object — hatsa_projector","title":"HATSA Projector Object — hatsa_projector","text":"S3 object class hatsa_projector stores results Harmonized Tensors SVD Alignment (HATSA) analysis. object inherits multiblock_biprojector (`multivarious` package) designed integrate HATSA outputs common framework multiblock data analysis. Creates hatsa_projector object, stores results HATSA algorithm designed integrate multivarious package, inheriting multiblock_biprojector.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HATSA Projector Object — hatsa_projector","text":"","code":"hatsa_projector(hatsa_core_results, parameters)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HATSA Projector Object — hatsa_projector","text":"hatsa_core_results list containing core outputs HATSA algorithm. Expected elements include: U_aligned_list: List subject-specific aligned sketch matrices (V_p x k). R_final_list: List subject-specific rotation matrices (k x k). U_original_list: List subject-specific original sketch matrices (V_p x k). Lambda_original_list: List subject-specific original eigenvalues (length k). Lambda_original_gaps_list: List subject-specific eigengap ratios (length k-1). T_anchor_final: final group anchor template matrix (N_anchors x k). parameters list parameters used run HATSA. Expected elements include: k: number spectral components (rank). N_subjects: number subjects. V_p: number parcels/vertices per subject. method: string, typically hatsa_core.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"HATSA Projector Object — hatsa_projector","text":"`hatsa_projector` object. object class c(\"hatsa_projector\", \"multiblock_biprojector\", \"projector\", \"list\").   object contains: v: group-level loading matrix (mean aligned sketch, V_p x k). s: stacked scores matrix (concatenated aligned sketches, (N*V_p) x k). sdev: Component standard deviations (defaulted 1s, length k). preproc: preprocessing object, set multivarious::prep(multivarious::pass()). block_indices: list defining rows s corresponding subject block. R_final_list: Stored input. U_original_list: Stored input. Lambda_original_list: Stored input (crucial voxel projection). Lambda_original_gaps_list: Stored input. T_anchor_final: Stored input. parameters: Stored input. method: Stored input parameters, typically hatsa_core.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"HATSA Projector Object — hatsa_projector","text":"v numeric matrix (V_p x k) representing mean aligned sketch, serving group-level template common loadings. s numeric matrix ((N*V_p) x k) stacked aligned sketches subjects. subject-specific parcel scores common space. sdev numeric vector length k, representing component-wise standard deviations (scales). Currently defaults vector 1s. preproc pre_processor object (`multivarious`). HATSA, typically `prep(pass())` input data `run_hatsa_core` already processed point raw time-series per subject. block_indices list defining rows scores matrix `s` belong subject (block). R_final_list list subject-specific rotation matrices (k x k) used align subject's original sketch common space. U_original_list list subject-specific original (unaligned) sketch matrices (V_p x k) derived parcel-level graph Laplacians. Lambda_original_list list numeric vectors, vector contains k original eigenvalues corresponding eigenvectors `U_original_list` subject. crucial Nyström voxel projection. Lambda_original_gaps_list list numeric vectors. vector contains k-1 eigengap ratios `(λ_j+1 - λ_j) / λ_j` corresponding subject's original eigenvalues. Useful assessing spectral stability. T_anchor_final numeric matrix (V_a x k, V_a number anchors) representing final group anchor template Procrustes alignment. parameters list containing input parameters used HATSA run (e.g., `k`, `V_p`, `N_subjects`, `anchor_indices`, `k_conn_pos`, `k_conn_neg`, `n_refine`). method character string, typically \"hatsa_core\", indicating method used generate projector. U_aligned_list (Internal) list subject-specific aligned sketch matrices (V_p x k). `s` provides stacked version, list might retained internally `run_hatsa_core` output passed constructor. user access aligned sketches per subject, one typically use `project_block(object, block = )` segment `scores(object)` using `block_indices(object)`.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_projector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"HATSA Projector Object — hatsa_projector","text":"","code":"# This is a conceptual example, as real data structures are complex. # Assuming hatsa_results and params are populated from run_hatsa_core: # projector_obj <- hatsa_projector( #   hatsa_core_results = list( #     U_aligned_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE), #     R_final_list = replicate(5, diag(10), simplify=FALSE), #     U_original_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE), #     Lambda_original_list = replicate(5, runif(10, 0.1, 1), simplify=FALSE), # example #     Lambda_original_gaps_list = replicate(5, runif(9, 0.05, 0.5), simplify=FALSE), # example #     T_anchor_final = matrix(rnorm(5*10), 5, 10) #   ), #   parameters = list( #     k=10, #     N_subjects=5, #     V_p=100, #     method=\"hatsa_core\" #   ) # ) # class(projector_obj) # names(projector_obj)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_suggest.html","id":null,"dir":"Reference","previous_headings":"","what":"Suggest HATSA Parameters — hatsa_suggest","title":"Suggest HATSA Parameters — hatsa_suggest","text":"Analyzes data suggests appropriate HATSA parameters based data characteristics dimensions, temporal structure, noise levels.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_suggest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Suggest HATSA Parameters — hatsa_suggest","text":"","code":"hatsa_suggest(data, task_data = NULL, verbose = TRUE)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_suggest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Suggest HATSA Parameters — hatsa_suggest","text":"data List subject data matrices (time × voxels) task_data Optional list task activation matrices verbose Logical, whether print explanations (default: TRUE)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_suggest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Suggest HATSA Parameters — hatsa_suggest","text":"list suggested parameters explanations","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_suggest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Suggest HATSA Parameters — hatsa_suggest","text":"","code":"if (FALSE) { # \\dontrun{ # Get parameter suggestions params <- hatsa_suggest(subject_data)  # Use suggested parameters result <- hatsa(subject_data,                  components = params$components,                 preset = params$preset) } # }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick Summary of HATSA Results — hatsa_summary","title":"Quick Summary of HATSA Results — hatsa_summary","text":"Provides concise overview HATSA alignment results key metrics diagnostic information.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick Summary of HATSA Results — hatsa_summary","text":"","code":"hatsa_summary(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick Summary of HATSA Results — hatsa_summary","text":"x hatsa_projector object ... Additional arguments (unused)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick Summary of HATSA Results — hatsa_summary","text":"Invisibly returns list summary statistics","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task.html","id":null,"dir":"Reference","previous_headings":"","what":"Task-Informed HATSA Interface — hatsa_task","title":"Task-Informed HATSA Interface — hatsa_task","text":"Simplified interface task-informed HATSA automatic method selection.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Task-Informed HATSA Interface — hatsa_task","text":"","code":"hatsa_task(   data,   task_data,   anchors = \"auto\",   components = 20,   method = c(\"auto\", \"blend\", \"gev\", \"augmented\"),   preset = c(\"default\", \"fast\", \"accurate\"),   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Task-Informed HATSA Interface — hatsa_task","text":"data List subject data matrices (time × voxels) task_data List task activation matrices anchors Either \"auto\" automatic selection, vector anchor indices components Number spectral components (default: 20) method Task incorporation method: \"auto\", \"blend\", \"gev\", \"augmented\" preset Configuration preset: \"default\", \"fast\", \"accurate\" ... Additional parameters passed run_task_hatsa","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Task-Informed HATSA Interface — hatsa_task","text":"task_hatsa_projector object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task_preset.html","id":null,"dir":"Reference","previous_headings":"","what":"Task-HATSA Configuration Presets — hatsa_task_preset","title":"Task-HATSA Configuration Presets — hatsa_task_preset","text":"Task-HATSA Configuration Presets","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_task_preset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Task-HATSA Configuration Presets — hatsa_task_preset","text":"","code":"hatsa_task_preset(preset_name, method)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_validate_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate HATSA Parameters — hatsa_validate_params","title":"Validate HATSA Parameters — hatsa_validate_params","text":"Checks provided parameters valid data suggests corrections needed.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_validate_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate HATSA Parameters — hatsa_validate_params","text":"","code":"hatsa_validate_params(   data,   anchor_indices,   spectral_rank_k,   k_conn_pos = 10,   k_conn_neg = 10,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_validate_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate HATSA Parameters — hatsa_validate_params","text":"data List subject data matrices anchor_indices Anchor indices validate spectral_rank_k Number components k_conn_pos Number positive edges k_conn_neg Number negative edges ... parameters validate","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/hatsa_validate_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate HATSA Parameters — hatsa_validate_params","text":"Invisible TRUE valid, otherwise stops informative error","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/load_anchors.html","id":null,"dir":"Reference","previous_headings":"","what":"Load Pre-selected Anchors — load_anchors","title":"Load Pre-selected Anchors — load_anchors","text":"Convenience function load previously selected anchors.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/load_anchors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load Pre-selected Anchors — load_anchors","text":"","code":"load_anchors(path, type = \"auto\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/load_anchors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load Pre-selected Anchors — load_anchors","text":"path Path saved anchors (directory file) type Type file load (\"rds\", \"txt\", \"auto\")","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/load_anchors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load Pre-selected Anchors — load_anchors","text":"Anchor indices full selection result","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_airm.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Map for SPD Matrices (AIRM Metric) — logmap_spd_airm","title":"Log Map for SPD Matrices (AIRM Metric) — logmap_spd_airm","text":"Projects SPD matrix S2 tangent space SPD matrix S1 using Affine-Invariant Riemannian Metric (AIRM). Tangent vector `S1^(1/2)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_airm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Map for SPD Matrices (AIRM Metric) — logmap_spd_airm","text":"","code":"logmap_spd_airm(S1, S2, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_airm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Map for SPD Matrices (AIRM Metric) — logmap_spd_airm","text":"S1 Reference SPD matrix. S2 SPD matrix project. regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_airm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Map for SPD Matrices (AIRM Metric) — logmap_spd_airm","text":"symmetric matrix (tangent vector S1).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_logeuclidean.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Map for SPD Matrices (Log-Euclidean Metric) — logmap_spd_logeuclidean","title":"Log Map for SPD Matrices (Log-Euclidean Metric) — logmap_spd_logeuclidean","text":"Projects SPD matrix S2 tangent space SPD matrix S1 using Log-Euclidean metric. tangent vector `logm(S2) - logm(S1)`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_logeuclidean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Map for SPD Matrices (Log-Euclidean Metric) — logmap_spd_logeuclidean","text":"","code":"logmap_spd_logeuclidean(S1, S2, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_logeuclidean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Map for SPD Matrices (Log-Euclidean Metric) — logmap_spd_logeuclidean","text":"S1 Reference SPD matrix (point manifold tangent space anchored). S2 SPD matrix project tangent space S1. regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/logmap_spd_logeuclidean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Map for SPD Matrices (Log-Euclidean Metric) — logmap_spd_logeuclidean","text":"symmetric matrix representing S2 tangent space S1.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_expm_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","title":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","text":"Computes matrix exponential symmetric matrix. result SPD matrix.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_expm_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","text":"","code":"matrix_expm_spd(S_symm)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_expm_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","text":"S_symm numeric, symmetric matrix (e.g., matrix tangent space).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_expm_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","text":"matrix exponential S_symm (SPD matrix).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_expm_spd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Exponential of a Symmetric Matrix — matrix_expm_spd","text":"","code":"S1 <- matrix(c(2.3, -0.3, -0.3, 3.6), 2, 2) logS1 <- matrix_logm_spd(S1) S1_reconstructed <- matrix_expm_spd(logS1) # all.equal(S1, S1_reconstructed) # Should be TRUE, up to numerical precision"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_logm_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","title":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","text":"Computes principal matrix logarithm symmetric positive-definite (SPD) matrix. input matrix first regularized ensure positive definiteness.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_logm_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","text":"","code":"matrix_logm_spd(S, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_logm_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","text":"S numeric, symmetric matrix. regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_logm_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","text":"matrix logarithm S (symmetric matrix).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_logm_spd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Logarithm of an SPD Matrix — matrix_logm_spd","text":"","code":"S1 <- matrix(c(2.3, -0.3, -0.3, 3.6), 2, 2) logS1 <- matrix_logm_spd(S1) print(logS1) #>            [,1]       [,2] #> [1,]  0.8266331 -0.1037649 #> [2,] -0.1037649  1.2762808"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_sqrt_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","title":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","text":"Computes principal matrix square root symmetric positive-definite (SPD) matrix. input matrix first regularized ensure positive definiteness. matrix square root S_sqrt S_sqrt","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_sqrt_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","text":"","code":"matrix_sqrt_spd(S, regularize_epsilon = 1e-06)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_sqrt_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","text":"S numeric, symmetric matrix. regularize_epsilon Epsilon regularization. Default 1e-6.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_sqrt_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","text":"matrix square root S (SPD matrix).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/matrix_sqrt_spd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Square Root of an SPD Matrix — matrix_sqrt_spd","text":"","code":"S1 <- matrix(c(2.3, -0.3, -0.3, 3.6), 2, 2) S1_sqrt <- matrix_sqrt_spd(S1) # S1_reconstructed_from_sqrt <- S1_sqrt %*% S1_sqrt # all.equal(S1, S1_reconstructed_from_sqrt) # Should be TRUE"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/message_stage.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for status messages — message_stage","title":"Helper for status messages — message_stage","text":"Prints timestamped stage message verbose TRUE. interactive_only TRUE message printed interactive sessions.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/message_stage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper for status messages — message_stage","text":"","code":"message_stage(message_text, verbose = TRUE, interactive_only = FALSE)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/message_stage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for status messages — message_stage","text":"message_text Text message display. verbose Whether print message. interactive_only Whether print interactive mode.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"Computes geodesic distance (k) two k x k rotation matrices, representing angle rotation needed align one . result given degrees.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"","code":"misalign_deg(R_est, R_true, method = \"geodesic\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"R_est k x k estimated rotation matrix (orthogonal determinant +1). R_true k x k true rotation matrix (orthogonal determinant +1). method Character string, method use. Default \"geodesic\". Currently, \"geodesic\" uses matrix logarithm. fallback simpler trace-based formula (accurate (3)) used `expm::logm` fails `expm` package installed.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"misalignment angle degrees. Returns 0 identical matrices.   Returns NA dimensions mismatched matrices square.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"primary method (\"geodesic\") calculates angle : `||logm(R_true^T R_est)||_F / sqrt(2)`, `logm` matrix logarithm `||.||_F` Frobenius norm. standard geodesic distance special orthogonal group (k). `expm` package available, `expm::logm` fails (e.g., due numerical issues matrices perfectly orthogonal), function falls back simpler formula derived trace: `acos((trace(R_true^T R_est) - 1) / 2)`. fallback formula exact (3) provides dissimilarity measure k, 0 perfect alignment.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/misalign_deg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Misalignment Angle Between Two Rotation Matrices — misalign_deg","text":"","code":"if (requireNamespace(\"expm\", quietly = TRUE)) {   R1 <- diag(3)   theta <- pi/4   R2 <- matrix(c(cos(theta), -sin(theta), 0,                  sin(theta),  cos(theta), 0,                  0,           0,          1), nrow=3, byrow=TRUE)   misalign_deg(R2, R1) # Should be 45 degrees    # Example for k=2   R_true_2d <- matrix(c(1,0,0,1),2,2)   angle_rad_2d <- pi/6 # 30 degrees   R_est_2d <- matrix(c(cos(angle_rad_2d), -sin(angle_rad_2d),                        sin(angle_rad_2d), cos(angle_rad_2d)), 2, 2)   misalign_deg(R_est_2d, R_true_2d) } #> [1] 30"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/parcel_quality_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Parcel-Level Quality Metrics — parcel_quality_metrics","title":"Compute Parcel-Level Quality Metrics — parcel_quality_metrics","text":"Computes quality metrics parcel/voxel, including well represented aligned space.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/parcel_quality_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Parcel-Level Quality Metrics — parcel_quality_metrics","text":"","code":"parcel_quality_metrics(   object,   type = c(\"reconstruction\", \"variance_captured\", \"connectivity_preservation\") )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/parcel_quality_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Parcel-Level Quality Metrics — parcel_quality_metrics","text":"object hatsa_projector object type Type quality metric: \"reconstruction\", \"variance_captured\", \"connectivity_preservation\"","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/parcel_quality_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Parcel-Level Quality Metrics — parcel_quality_metrics","text":"matrix (parcels × subjects) vector quality scores","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_geometric_gpa_refinement.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","title":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","text":"Refines set rotation matrices group anchor template using either SVD-based iterative Procrustes approach (default) variant template update oriented Frechet mean rotations. SVD mode minimizes Frobenius distance rotated subject anchors template. Riemannian mode aims make template's orientation consistent Frechet mean subject rotations, implicitly relates minimizing intrinsic (k) geodesic distances rotations' central tendency.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_geometric_gpa_refinement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","text":"","code":"perform_geometric_gpa_refinement(   A_originals_list,   n_refine = 10,   k,   m_rows,   tol = 1e-07,   rotation_mode = c(\"svd\", \"riemannian\"),   frechet_mean_options = list(),   verbose = TRUE,   initial_R_list = NULL )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_geometric_gpa_refinement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","text":"A_originals_list list subject-specific anchor matrices (m_rows x k). matrix `A_i` contains rows `U_original_list[[]]` corresponding `unique_anchor_indices`. n_refine Integer, number GPA refinement iterations. Default: 10. k Integer, dimensionality sketch space (number columns A_i R_i). m_rows Integer, number anchor features (number rows A_i). tol Numeric, tolerance convergence based relative Frobenius norm change template `T_template`. Default: 1e-7. rotation_mode Character string, one `\"svd\"` (default) `\"riemannian\"`. - `\"svd\"`: Uses SVD find closest (k) rotation subject align   `A_i` `T_template`. `T_template` Euclidean mean `A_i R_i`.   mode minimizes sum squared Frobenius distances `sum(||A_i R_i - T||_F^2)`. - `\"riemannian\"`: Individual rotations `R_i` updated `\"svd\"` mode.   However, `T_template` updated first computing Frechet mean (`R_bar`)   current `R_list`, averaging `A_i R_i R_bar^T` (configurations aligned   `R_bar`'s frame), finally rotating average back `R_bar`.   mode seeks make template orientation consistent intrinsic   mean rotation ensemble. frechet_mean_options list options pass `hatsa::frechet_mean_so_k`, used `rotation_mode = \"riemannian\"` final `R_bar_final` computation. Example: `list(max_iter = 20, tol = 1e-5)`. Defaults used provided. verbose Logical, TRUE, prints progress messages. Default TRUE. initial_R_list Optional list initial k x k rotation matrices. NULL, identity matrices used.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_geometric_gpa_refinement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","text":"list containing:   - `R_final_list`: List final subject-specific rotation matrices (k x k).   - `T_anchor_final`: final group anchor template matrix (m_rows x k).   - `R_bar_final`: Fréchet mean final `R_final_list`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_geometric_gpa_refinement.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Geometric Generalized Procrustes Analysis (Geo-GPA) on SO(k) — perform_geometric_gpa_refinement","text":"Matrices `A_originals_list` checked numeric dimensions `m_rows x k` initial template computed. Invalid matrices ignored indices reported warning. matrices invalid, function returns identity rotations `NA` template rather stopping error.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_gpa_refinement.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Generalized Procrustes Analysis (GPA) refinement iterations — perform_gpa_refinement","title":"Perform Generalized Procrustes Analysis (GPA) refinement iterations — perform_gpa_refinement","text":"Iteratively refines subject rotations group anchor template. Can use weighted Procrustes task rows present omega_mode specified. n_refine = 0, computes initial rotations mean template update template.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_gpa_refinement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Generalized Procrustes Analysis (GPA) refinement iterations — perform_gpa_refinement","text":"","code":"perform_gpa_refinement(   A_originals_list,   n_refine,   k,   m_parcel_rows = NULL,   m_task_rows = 0,   omega_mode = \"fixed\",   fixed_omega_weights = NULL,   reliability_scores_list = NULL,   scale_omega_trace = TRUE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_gpa_refinement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Generalized Procrustes Analysis (GPA) refinement iterations — perform_gpa_refinement","text":"A_originals_list List `(m_parcels + m_tasks) x k` anchor matrices `N` subjects. n_refine Integer, number refinement iterations. k Integer, spectral rank (number columns anchor matrices). m_parcel_rows Integer, number rows corresponding parcel anchors. Required `m_task_rows > 0` weighted Procrustes. m_task_rows Integer, number rows corresponding task anchors. Default 0. > 0, `solve_procrustes_rotation_weighted` used. omega_mode Character string, mode `solve_procrustes_rotation_weighted`. Default `\"fixed\"`. Ignored `m_task_rows == 0`. fixed_omega_weights List, weights `\"fixed\"` mode. Passed weighted solver. Default `list(parcel = 1.0, condition = 0.5)` handled weighted solver NULL. reliability_scores_list List (parallel `A_originals_list`), element numeric vector reliability scores task anchors. Used `omega_mode == \"adaptive\"` `m_task_rows > 0`. `NULL`, adaptive mode solver may use default behavior. scale_omega_trace Logical, passed weighted solver. Default `TRUE`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/perform_gpa_refinement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Generalized Procrustes Analysis (GPA) refinement iterations — perform_gpa_refinement","text":"List: `R_final_list` (list `k x k` rotation matrices),         `T_anchor_final` (final `(m_parcels+m_tasks) x k` group anchor template).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_hatsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot HATSA Results — plot_hatsa","title":"Plot HATSA Results — plot_hatsa","text":"Creates diagnostic plots HATSA alignment results.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_hatsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot HATSA Results — plot_hatsa","text":"","code":"plot_hatsa(x, type = c(\"eigenvalues\", \"rotation_quality\", \"alignment\"), ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_hatsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot HATSA Results — plot_hatsa","text":"x hatsa_projector object type Plot type: \"eigenvalues\", \"rotation_quality\", \"alignment\" ... Additional plotting parameters","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_k_stability_hatsa.html","id":null,"dir":"Reference","previous_headings":"","what":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","title":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","text":"file contains functions generating QC plots, k-stability plots, HATSA results.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_k_stability_hatsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","text":"","code":"plot_k_stability_hatsa(   projector_list_over_k,   metrics_to_plot = c(\"Hk\", \"CV_eigen_cov\"),   Hk_dispersion_stat = \"mean\",   spd_cov_coeffs_options = list(),   Hk_options = list(),   verbose = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_k_stability_hatsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","text":"projector_list_over_k list hatsa_projector objects. object result HATSA run different 'k'. list can named k values, k extracted object. metrics_to_plot character vector specifying metrics plot. Possible values \"Hk\" (Alignment Homogeneity based Riemannian dispersion covariance aligned coefficients) /\"CV_eigen_cov\" (Mean Coefficient Variation eigenvalues covariance aligned coefficients). Default c(\"Hk\", \"CV_eigen_cov\"). Hk_dispersion_stat Character, either \"mean\" (default) \"median\". Specifies statistic riemannian_dispersion_spd use Hk. spd_cov_coeffs_options list additional arguments pass hatsa::get_spd_representations(..., type = \"cov_coeffs\"). example, list(spd_regularize_epsilon = 1e-6). Hk_options list additional arguments pass hatsa::riemannian_dispersion_spd(...). example, list(tangent_metric = \"logeuclidean\", use_geometric_median = FALSE). Note `use_geometric_median` overridden `Hk_dispersion_stat == \"median\"`. verbose Logical, TRUE, prints progress messages. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_k_stability_hatsa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","text":"ggplot object containing stability plots, NULL   valid metrics can computed.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_k_stability_hatsa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"HATSA Quality Control and Stability Plots — plot_k_stability_hatsa","text":"","code":"# Conceptual example: # Assume projector_k3, projector_k4, projector_k5 are hatsa_projector objects # k_list <- list(\"3\" = projector_k3, \"4\" = projector_k4, \"5\" = projector_k5) # plot_k_stability_hatsa(k_list)  # To run if example data were available: # if (requireNamespace(\"ggplot2\", quietly = TRUE) && #     exists(\"generate_synthetic_hatsa_output_list\")) { #   example_projector_list <- generate_synthetic_hatsa_output_list( #      k_values = c(3, 4, 5, 6), N_subjects = 5, V_p = 20 #   ) #   plot_k_stability_hatsa(example_projector_list) # }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_mds_spd_subjects.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","title":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","text":"Computes Riemannian distances subjects based SPD matrix representations, performs classical MDS, plots subjects low-dimensional space (typically 2D).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_mds_spd_subjects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","text":"","code":"plot_mds_spd_subjects(   projector_object,   k_mds = 2,   spd_representation_type = \"cov_coeffs\",   dist_mat_options = list(),   subject_info = NULL,   color_by_column = NULL,   shape_by_column = NULL,   plot_labels = FALSE,   cmdscale_add = TRUE,   verbose = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_mds_spd_subjects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","text":"projector_object hatsa_projector task_hatsa_projector object. k_mds Integer, number MDS dimensions compute (default: 2). spd_representation_type Character string, type SPD representation use distance calculation (e.g., \"cov_coeffs\", \"fc_conn\"). passed hatsa::riemannian_distance_matrix_spd. dist_mat_options list additional arguments pass hatsa::riemannian_distance_matrix_spd. can include arguments like spd_metric, subject_data_list (needed chosen type), k_conn_params, spd_regularize_epsilon, verbose, etc. subject_info Optional. data frame N_subjects rows. provided, can contain column named subject_label text labels plot, columns can mapped ggplot aesthetics (e.g., column named color_by_column shape_by_column). Row names subject_info correspond subject indices (1 N) actual subject IDs distance matrix . color_by_column Character string. subject_info provided, name column subject_info use coloring points. shape_by_column Character string. subject_info provided, name column subject_info use point shapes. plot_labels Logical, whether plot subject labels near points. Requires subject_label column subject_info uses default labels. Consider using ggrepel package better label placement many points overlap (directly implemented reduce dependencies). cmdscale_add Logical, add argument stats::cmdscale (default: TRUE). Useful distances perfectly Euclidean. verbose Logical, TRUE, prints progress messages. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_mds_spd_subjects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","text":"list containing: plot: ggplot object MDS plot. mds_results: output stats::cmdscale, including           coordinates (points), eigenvalues (eig), etc. distance_matrix: computed Riemannian distance matrix. valid_subject_indices: Indices subjects included MDS (NA removal). Returns NULL critical steps fail (e.g., distance matrix computation).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/plot_mds_spd_subjects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Multidimensional Scaling (MDS) of Subjects based on SPD Matrix Distances — plot_mds_spd_subjects","text":"","code":"# Conceptual example, assuming 'proj_obj' is a hatsa_projector object # and subject_covariates is a data frame with N_subjects rows # and columns \"ID\" (for labels), \"Group\" (for color).  # if (requireNamespace(\"ggplot2\", quietly = TRUE) && #     exists(\"generate_synthetic_hatsa_output\") && # Assuming a single projector gen #     exists(\"hatsa_projector\")) { # Ensure constructor is available # #   # Generate a single projector object #   N_subj_example <- 10 #   V_p_example <- 30 #   k_example <- 5 #   proj_params <- list(k = k_example, N_subjects = N_subj_example, V_p = V_p_example, #                       method=\"hatsa_core\", anchor_indices = 1:5) #   proj_core_res <- list( #      U_aligned_list = replicate(N_subj_example, matrix(rnorm(V_p_example*k_example), V_p_example, k_example), simplify=FALSE), #      R_final_list = replicate(N_subj_example, diag(k_example), simplify=FALSE), #      U_original_list = replicate(N_subj_example, matrix(rnorm(V_p_example*k_example), V_p_example, k_example), simplify=FALSE), #      Lambda_original_list = replicate(N_subj_example, sort(runif(k_example, 0.1, 1), decreasing=TRUE), simplify=FALSE), #      Lambda_original_gaps_list = replicate(N_subj_example, { #         lams <- sort(runif(k_example, 0.1, 1), decreasing=TRUE); if(k_example>1) (lams[1:(k_example-1)] - lams[2:k_example])/lams[2:k_example] else numeric(0) #         }, simplify=FALSE), #      T_anchor_final = matrix(rnorm(min(5,V_p_example)*k_example), min(5,V_p_example), k_example) #    ) #   proj_obj <- hatsa::hatsa_projector(proj_core_res, proj_params) # #   # Example subject_info #   subject_covariates <- data.frame( #     subject_label = paste0(\"S\", 1:N_subj_example), #     Group = factor(rep(c(\"A\", \"B\"), each = N_subj_example / 2)), #     stringsAsFactors = FALSE #   ) # #   # Run MDS plot #   mds_plot_result <- plot_mds_spd_subjects( #     projector_object = proj_obj, #     spd_representation_type = \"cov_coeffs\", #     dist_mat_options = list(spd_metric = \"logeuclidean\", spd_regularize_epsilon = 1e-6), #     subject_info = subject_covariates, #     color_by_column = \"Group\", #     plot_labels = TRUE, #     verbose = TRUE #   ) #   if (!is.null(mds_plot_result)) print(mds_plot_result$plot) # }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/predict.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for hatsa_projector objects — predict.hatsa_projector","title":"Predict method for hatsa_projector objects — predict.hatsa_projector","text":"Projects new subject-level parcel time-series data common space defined fitted HATSA model.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/predict.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for hatsa_projector objects — predict.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' predict(object, newdata_list, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/predict.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for hatsa_projector objects — predict.hatsa_projector","text":"object fitted hatsa_projector object. newdata_list list new subject data. element list numeric matrix representing parcel time-series data one subject (T_i time points x V_p parcels). Parcel count (V_p) must match original data. ... Additional arguments (currently unused, S3 compatibility).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/predict.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for hatsa_projector objects — predict.hatsa_projector","text":"list aligned spectral sketch matrices (U_aligned_new, V_p x k),   one subject newdata_list.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_mds_plot_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data for MDS Plot — prepare_mds_plot_df","title":"Prepare Data for MDS Plot — prepare_mds_plot_df","text":"Creates data frame MDS coordinates merged optional subject information plotting.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_mds_plot_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data for MDS Plot — prepare_mds_plot_df","text":"","code":"prepare_mds_plot_df(   mds_fit,   valid_subject_indices,   valid_subjects_mask,   n_total_subjects,   subject_info = NULL,   plot_labels = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_mds_plot_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data for MDS Plot — prepare_mds_plot_df","text":"mds_fit Result `run_cmdscale_safe`. valid_subject_indices Indices subjects included analysis. valid_subjects_mask Logical vector identifying valid subjects original distance matrix. n_total_subjects Total number subjects projector object. subject_info Optional data frame one row per subject. plot_labels Logical indicating labels prepared.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_mds_plot_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data for MDS Plot — prepare_mds_plot_df","text":"data frame suitable `ggplot2`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_parcel_quality_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Parcel Quality Information — prepare_parcel_quality_info","title":"Prepare Parcel Quality Information — prepare_parcel_quality_info","text":"Creates parcel quality information structure can used guide anchor selection.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_parcel_quality_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Parcel Quality Information — prepare_parcel_quality_info","text":"","code":"prepare_parcel_quality_info(   U_pilot_list,   spectral_rank_k,   compute_metrics = c(\"stability\", \"coverage\", \"snr\"),   custom_quality = NULL )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_parcel_quality_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Parcel Quality Information — prepare_parcel_quality_info","text":"U_pilot_list List pilot subject sketch matrices spectral_rank_k Number spectral components compute_metrics Character vector metrics compute custom_quality Optional pre-computed quality scores","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/prepare_parcel_quality_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Parcel Quality Information — prepare_parcel_quality_info","text":"data frame parcel quality information","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.anchor_selection_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Anchor Selection Result — print.anchor_selection_result","title":"Print Anchor Selection Result — print.anchor_selection_result","text":"Print Anchor Selection Result","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.anchor_selection_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Anchor Selection Result — print.anchor_selection_result","text":"","code":"# S3 method for class 'anchor_selection_result' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.anchor_validation_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Anchor Validation Result — print.anchor_validation_result","title":"Print Anchor Validation Result — print.anchor_validation_result","text":"Print Anchor Validation Result","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.anchor_validation_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Anchor Validation Result — print.anchor_validation_result","text":"","code":"# S3 method for class 'anchor_validation_result' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for hatsa_projector objects — print.hatsa_projector","title":"Print method for hatsa_projector objects — print.hatsa_projector","text":"Provides concise summary hatsa_projector object.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for hatsa_projector objects — print.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for hatsa_projector objects — print.hatsa_projector","text":"x hatsa_projector object. ... Additional arguments passed print.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for hatsa_projector objects — print.hatsa_projector","text":"Invisibly returns input object x.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.hatsa_projector objects — print.summary.hatsa_projector","title":"Print method for summary.hatsa_projector objects — print.summary.hatsa_projector","text":"Print method summary.hatsa_projector objects","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.hatsa_projector objects — print.summary.hatsa_projector","text":"","code":"# S3 method for class 'summary.hatsa_projector' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.hatsa_projector objects — print.summary.hatsa_projector","text":"x summary.hatsa_projector object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.hatsa_projector objects — print.summary.hatsa_projector","text":"Invisibly returns input object x.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.task_hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.task_hatsa_projector objects — print.summary.task_hatsa_projector","title":"Print method for summary.task_hatsa_projector objects — print.summary.task_hatsa_projector","text":"Print method summary.task_hatsa_projector objects","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.task_hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.task_hatsa_projector objects — print.summary.task_hatsa_projector","text":"","code":"# S3 method for class 'summary.task_hatsa_projector' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.task_hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.task_hatsa_projector objects — print.summary.task_hatsa_projector","text":"x `summary.task_hatsa_projector` object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary.task_hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.task_hatsa_projector objects — print.summary.task_hatsa_projector","text":"Invisibly returns input object x.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary_enhanced_hatsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Enhanced Summary — print.summary_enhanced_hatsa","title":"Print Enhanced Summary — print.summary_enhanced_hatsa","text":"Print Enhanced Summary","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary_enhanced_hatsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Enhanced Summary — print.summary_enhanced_hatsa","text":"","code":"# S3 method for class 'summary_enhanced_hatsa' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.summary_enhanced_hatsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Enhanced Summary — print.summary_enhanced_hatsa","text":"x Enhanced summary object ... Additional arguments","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.task_hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for task_hatsa_projector objects — print.task_hatsa_projector","title":"Print method for task_hatsa_projector objects — print.task_hatsa_projector","text":"Print method task_hatsa_projector objects","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.task_hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for task_hatsa_projector objects — print.task_hatsa_projector","text":"","code":"# S3 method for class 'task_hatsa_projector' print(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.task_hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for task_hatsa_projector objects — print.task_hatsa_projector","text":"x `task_hatsa_projector` object. ... Additional arguments passed print.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/print.task_hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for task_hatsa_projector objects — print.task_hatsa_projector","text":"Invisibly returns input object x.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/procrustes_rotation_basic.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic SVD-based Procrustes rotation solver — procrustes_rotation_basic","title":"Basic SVD-based Procrustes rotation solver — procrustes_rotation_basic","text":"Computes cross-product `t()  standard determinant correction returned rotation lies `(k)`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/procrustes_rotation_basic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic SVD-based Procrustes rotation solver — procrustes_rotation_basic","text":"","code":"procrustes_rotation_basic(A, T)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/procrustes_rotation_basic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic SVD-based Procrustes rotation solver — procrustes_rotation_basic","text":"Numeric matrix. T Numeric matrix dimensions ``.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/procrustes_rotation_basic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic SVD-based Procrustes rotation solver — procrustes_rotation_basic","text":"Rotation matrix `det(R) = 1`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_block.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Project a specific block (subject) using a hatsa_projector object — project_block.hatsa_projector","title":"Project a specific block (subject) using a hatsa_projector object — project_block.hatsa_projector","text":"Retrieves aligned spectral sketch specified subject. new data subject provided, projects new data. Otherwise, extracts stored aligned sketch original analysis.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_block.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project a specific block (subject) using a hatsa_projector object — project_block.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' project_block(object, newdata = NULL, block, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_block.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project a specific block (subject) using a hatsa_projector object — project_block.hatsa_projector","text":"object fitted hatsa_projector object. newdata Optional. single numeric matrix parcel time-series data (T_i x V_p) subject specified block. NULL, stored sketch block returned. provided, new data projected. block integer, index subject (block) project. ... Additional arguments passed predict.hatsa_projector newdata provided.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_block.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project a specific block (subject) using a hatsa_projector object — project_block.hatsa_projector","text":"matrix (V_p x k) representing aligned spectral sketch   specified subject/block. Returns NULL raises error block invalid   data inappropriate.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_features_to_spectral_space.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Features onto a Spectral Basis — project_features_to_spectral_space","title":"Project Features onto a Spectral Basis — project_features_to_spectral_space","text":"Projects feature matrix onto given spectral basis. Handles potential   transposition feature matrix uses appropriate orthogonal projection   formula based whether basis orthonormal. Sparse inputs processed   `Matrix` methods large matrices need fully densified.   returned matrix always dense.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_features_to_spectral_space.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Features onto a Spectral Basis — project_features_to_spectral_space","text":"","code":"project_features_to_spectral_space(   feature_matrix,   U_basis,   tol_orthonormal = sqrt(.Machine$double.eps),   assume_orthonormal = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_features_to_spectral_space.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Features onto a Spectral Basis — project_features_to_spectral_space","text":"feature_matrix numeric matrix representing features. can `V_p x C` format (parcels x features/conditions) `C x V_p` format. function attempt orient correctly based `U_basis`. `feature_matrix` sparse `Matrix`, operations use sparse methods possible (coercion occurs small intermediate matrices). large sparse inputs (`prod(dim(.)) > 1e7`) trigger error avoid accidental densification. U_basis numeric matrix representing spectral basis, typically dimensions `V_p x k_dims_basis` (parcels x basis dimensions). Sparse `U_basis` inputs handled `Matrix` methods. Extremely large sparse bases also trigger error prevent densification. tol_orthonormal numeric tolerance check orthonormality `U_basis`. `max(abs(crossprod(U_basis) - )) / k_dims_basis` compared tolerance. Default `sqrt(.Machine$double.eps)`. assume_orthonormal Logical. `TRUE`, `U_basis` assumed orthonormal, check (including rank check `UtU` calculation) skipped, directly using faster projection `crossprod(U_basis, features)`. Default `FALSE`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_features_to_spectral_space.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Features onto a Spectral Basis — project_features_to_spectral_space","text":"numeric (dense) matrix containing projected features.   `feature_matrix` oriented `V_p x C` (parcels x features/conditions),   output `k_dims_basis x C` (basis dimensions x features/conditions).   `feature_matrix` `C x V_p` transposed projection, output   `C x k_dims_basis` maintain original feature orientation rows.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_features_to_spectral_space.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project Features onto a Spectral Basis — project_features_to_spectral_space","text":"","code":"V_p <- 10 k_dims <- 3 C <- 5 U_basis_ortho <- svd(matrix(rnorm(V_p * k_dims), V_p, k_dims))$u U_basis_non_ortho <- matrix(rnorm(V_p * k_dims), V_p, k_dims)  # Feature matrix: V_p x C (parcels x conditions) features1 <- matrix(rnorm(V_p * C), V_p, C) proj1_ortho <- project_features_to_spectral_space(features1, U_basis_ortho) print(dim(proj1_ortho)) #> [1] 3 5 proj1_non_ortho <- project_features_to_spectral_space(features1, U_basis_non_ortho) print(dim(proj1_non_ortho)) #> [1] 3 5  # Sparse input example features_sp <- Matrix::rsparsematrix(V_p, C, 0.2) proj_sp <- project_features_to_spectral_space(features_sp, U_basis_ortho) #> Error in project_features_to_spectral_space(features_sp, U_basis_ortho): feature_matrix must be a numeric matrix or Matrix object. print(class(proj_sp)) #> Error: object 'proj_sp' not found  # Ambiguous square matrix error V_p_sq <- 7 U_basis_sq <- matrix(rnorm(V_p_sq*k_dims), V_p_sq, k_dims) features_sq_ambiguous <- matrix(rnorm(V_p_sq*V_p_sq), V_p_sq, V_p_sq) try(project_features_to_spectral_space(features_sq_ambiguous, U_basis_sq)) #> Error in project_features_to_spectral_space(features_sq_ambiguous, U_basis_sq) :  #>   feature_matrix dimensions (7 x 7) are ambiguous as both match V_p_basis (7). Please ensure feature_matrix is oriented as V_p x C (parcels x features/conditions). If unsure, or if it is C x V_p where C == V_p, please transpose it first before calling.  # Rank deficient U_basis warning U_rank_def <- matrix(rnorm(V_p * k_dims), V_p, k_dims) if (k_dims > 1) U_rank_def[, k_dims] <- U_rank_def[, 1] # Make last col same as first try(project_features_to_spectral_space(features1, U_rank_def)) #> Warning: U_basis appears rank deficient (rank 2 / 3 dimensions). Projection results may be unreliable or reflect a lower-dimensional space. #> Error in value[[3L]](cond) :  #>   Error in qr.solve, likely UtU is singular or ill-conditioned (U_basis may be rank-deficient, or k_dims_basis > V_p_basis and U_basis not full rank). Original error: singular matrix 'a' in solve"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"Projects voxel-level time series data common aligned space defined hatsa_projector object. method uses Nyström extension.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' project_voxels(   object,   voxel_timeseries_list,   voxel_coords,   parcel_coords,   n_nearest_parcels = 10,   kernel_sigma = \"auto\",   W_vox_parc = NULL,   data_type = c(\"timeseries\", \"coefficients\"),   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"object fitted hatsa_projector object. voxel_timeseries_list list voxel time-series matrices (T_i x V_v). assumed -th element list corresponds -th subject stored hatsa_projector object (e.g., U_original_list). voxel_coords numeric matrix (V_v x 3) voxel coordinates. parcel_coords numeric matrix (V_p x 3) parcel centroid coordinates corresponding parcellation used fit object. n_nearest_parcels Integer, number nearest parcels Nyström extension. Passed compute_voxel_basis_nystrom. kernel_sigma Numeric \"auto\", kernel bandwidth Nyström extension. Passed compute_voxel_basis_nystrom. W_vox_parc Optional pre-computed voxel--parcel affinity matrix (V_v x V_p). provided, matrix reused subjects internal k-NN search Gaussian kernel calculation skipped. NULL (default), affinity matrix computed using n_nearest_parcels kernel_sigma reused. data_type Character string, either \"timeseries\" (default) \"coefficients\". \"timeseries\", projection involves scaling `1/T_i` (number time points) estimate covariance basis. \"coefficients\" (e.g., projecting beta maps statistical maps), scaling omitted. ... Additional arguments passed compute_voxel_basis_nystrom.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"list aligned voxel coefficient matrices. element `[[]]`   matrix dimensions T_i x k, T_i number time points (rows)   input `voxel_timeseries_list[[]]`, k number HATSA components.   represent projection coefficients voxel data onto aligned   HATSA basis subject.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"assumed voxel_coords parcel_coords Cartesian coordinate system units (e.g., millimeters MNI-aligned space). function includes heuristic checks gross inconsistencies coordinate systems (see ..validate_coordinate_inputs details checks performed), issuing messages potential issues like substantially different ranges scales detected. Nyström extension formulated consistent unnormalized graph Laplacian used core HATSA algorithm parcel-level decomposition. See compute_voxel_basis_nystrom details parameters like row_normalize_W control Nyström calculation.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"","dir":"Reference","previous_headings":"","what":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"NA","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.hatsa_projector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project Voxel-Level Data using a HATSA Projector — project_voxels.hatsa_projector","text":"","code":"# This is a conceptual example. For it to run, you need a fitted hatsa_projector. # First, let's set up parameters for a minimal run_hatsa_core call. set.seed(456) N_subj_fit <- 2 V_parc_fit <- 20 # Number of parcels in the fitted model k_comp_fit <- 3   # Number of components in the fitted model T_time_fit <- 40  # Number of time points for parcel data  # Generate mock parcel-level data for fitting HATSA subject_parcel_data <- lapply(1:N_subj_fit, function(i) {   matrix(stats::rnorm(T_time_fit * V_parc_fit), ncol = V_parc_fit) }) anchor_idx_fit <- sample(1:V_parc_fit, min(V_parc_fit, 5))  # Fit a hatsa_projector object (requires Matrix and RSpectra) fitted_hatsa_model <- NULL if (requireNamespace(\"Matrix\", quietly = TRUE) &&      requireNamespace(\"RSpectra\", quietly = TRUE) &&     exists(\"run_hatsa_core\")) {   fitted_hatsa_model <- tryCatch({     run_hatsa_core(       subject_data_list = subject_parcel_data,       anchor_indices    = anchor_idx_fit,       spectral_rank_k = k_comp_fit,       k_conn_pos        = min(5, V_parc_fit -1),       k_conn_neg        = min(2, V_parc_fit -1),       n_refine          = 1     )   }, error = function(e) NULL) # Return NULL on error for example }  if (!is.null(fitted_hatsa_model)) {   # Now, prepare data for project_voxels   N_subj_proj <- N_subj_fit # Number of subjects for voxel projection   V_vox_proj  <- 50         # Number of voxels   T_time_vox  <- 35         # Number of time points for voxel data    # Mock voxel time-series data   voxel_ts_list <- lapply(1:N_subj_proj, function(i) {     matrix(stats::rnorm(T_time_vox * V_vox_proj), ncol = V_vox_proj)   })    # Mock coordinates   voxel_coords_map <- matrix(stats::rnorm(V_vox_proj * 3), ncol = 3)   # Parcel coords must match the V_p used when fitting the model   parcel_coords_map <- matrix(stats::rnorm(V_parc_fit * 3), ncol = 3)     # Project voxel data   projected_vox_coeffs <- project_voxels(     object = fitted_hatsa_model,     voxel_timeseries_list = voxel_ts_list,     voxel_coords = voxel_coords_map,     parcel_coords = parcel_coords_map,     n_nearest_parcels = 5, # Nystrom param     kernel_sigma = \"auto\"    # Nystrom param   )    # print(str(projected_vox_coeffs, max.level=1))   # if (length(projected_vox_coeffs) > 0) {   #   print(dim(projected_vox_coeffs[[1]])) # Should be T_time_vox x k_comp_fit   # } } else {   if (interactive()) message(\"Skipping project_voxels example: fitted_hatsa_model not created.\") }"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Voxel-Level Data — project_voxels","title":"Project Voxel-Level Data — project_voxels","text":"Generic S3 method projecting voxel-level data using fitted model object.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Voxel-Level Data — project_voxels","text":"","code":"project_voxels(object, voxel_timeseries_list, voxel_coords, parcel_coords, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Voxel-Level Data — project_voxels","text":"object fitted model object (e.g., hatsa_projector). voxel_timeseries_list list voxel time-series matrices. voxel_coords Coordinates voxels. parcel_coords Coordinates parcels used model. ... Additional arguments specific method.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/project_voxels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Voxel-Level Data — project_voxels","text":"list projected voxel data, specific method implementation.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/reconstruction_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","title":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","text":"Computes various types reconstruction errors based fitted HATSA model. helps quantify alignment quality, sanity check model components, assess well non-anchor information captured.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/reconstruction_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","text":"","code":"reconstruction_error(object, type = \"anchors\", ...)  # S3 method for class 'hatsa_projector' reconstruction_error(object, type = \"anchors\", ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/reconstruction_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","text":"object fitted hatsa_projector object. type character string specifying type reconstruction error compute. One : \"anchors\" (Default): Error subject-specific aligned anchor sketches         group anchor template (`T_anchor_final`). \"all_parcels\": Error original subject sketches (`U_original_list`)         sketches reconstructed aligned versions via inverse rotation.         (Sanity check, near zero rotations orthogonal). \"non_anchors\": Error predicting non-anchor parcel sketches         anchor parcel sketches aligned space (Anchor Residual `ε̄`). ... Additional arguments, potentially passed internal helper functions (e.g., non-anchor prediction methods).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/reconstruction_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","text":"named list containing reconstruction error metrics. structure depends   `type` requested, typically including `mean_error` `per_subject_error`.   `type=\"non_anchors\"`, also includes `per_parcel_error`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/reconstruction_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Reconstruction Error for HATSA Projector Objects — reconstruction_error","text":"","code":"# Assuming `fit_obj` is a hatsa_projector from `run_hatsa_core()` # Anchor reconstruction error # reconstruction_error(fit_obj, type = \"anchors\") # Sanity check using all parcels # reconstruction_error(fit_obj, type = \"all_parcels\") # Predict non-anchor parcels from anchors # reconstruction_error(fit_obj, type = \"non_anchors\")"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_graph_on_subspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Residualize Graph B based on Subspace from Graph A's Laplacian — residualize_graph_on_subspace","title":"Residualize Graph B based on Subspace from Graph A's Laplacian — residualize_graph_on_subspace","text":"Projects `W_graph_to_residualize` onto subspace spanned first `k_eigenvectors_to_remove` smallest eigenvectors `L_graph_for_projection` subtracts projection. residual graph re-sparsified re-z-scored.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_graph_on_subspace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residualize Graph B based on Subspace from Graph A's Laplacian — residualize_graph_on_subspace","text":"","code":"residualize_graph_on_subspace(   W_graph_to_residualize,   L_graph_for_projection,   k_eigenvectors_to_remove = 64,   k_nn_resparsify,   eigenvalue_tol = 1e-09 )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_graph_on_subspace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residualize Graph B based on Subspace from Graph A's Laplacian — residualize_graph_on_subspace","text":"W_graph_to_residualize sparse graph matrix (`dgCMatrix`) residualized (e.g., `W_task`). L_graph_for_projection sparse Laplacian matrix (`dgCMatrix`) projection subspace derived (e.g., `L_conn`). Must symmetric. k_eigenvectors_to_remove Integer, number smallest (magnitude) eigenvectors `L_graph_for_projection` define subspace projection. Defaults 64. k_nn_resparsify Integer, k value k-NN sparsification applied residual graph (k used positive negative edges). eigenvalue_tol Numeric, tolerance eigenvalue decomposition convergence identifying near-zero eigenvalues needed (though projection uses space). Default 1e-9.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_graph_on_subspace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residualize Graph B based on Subspace from Graph A's Laplacian — residualize_graph_on_subspace","text":"sparse, symmetric, z-scored `dgCMatrix` representing residualized graph.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_matrix_on_subspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","title":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","text":"Residualizes rows `matrix_to_residualize` respect   row space `subspace_basis_matrix`. equivalent projecting   column `t(matrix_to_residualize)` onto column space   `t(subspace_basis_matrix)` taking residuals. Sparse inputs   processed `Matrix` routines result returned dense   matrix.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_matrix_on_subspace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","text":"","code":"residualize_matrix_on_subspace(matrix_to_residualize, subspace_basis_matrix)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_matrix_on_subspace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","text":"matrix_to_residualize numeric matrix (e.g., `C x k`) whose rows residualized. Sparse `Matrix` inputs handled without full densification. warning issued matrix large (`C*k > 1e7`). subspace_basis_matrix numeric matrix (e.g., `m x k`) whose rows span subspace project . Sparse matrices accepted processed `Matrix` linear algebra.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_matrix_on_subspace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","text":"numeric matrix dimensions `matrix_to_residualize`,   containing residualized rows.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/residualize_matrix_on_subspace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residualize Matrix on Subspace — residualize_matrix_on_subspace","text":"","code":"# Z_i: 3 conditions, 5-dimensional spectral space (3x5) Z_i <- matrix(rnorm(15), nrow = 3, ncol = 5) # A_parc_i: 2 anchor parcels, 5-dimensional spectral space (2x5) A_parc_i <- matrix(rnorm(10), nrow = 2, ncol = 5) Z_i_res <- residualize_matrix_on_subspace(Z_i, A_parc_i) print(dim(Z_i_res)) #> [1] 3 5 if (nrow(A_parc_i) > 0 && ncol(A_parc_i) > 0 && qr(t(A_parc_i))$rank > 0) {   # Test orthogonality: Z_i_res %*% t(A_parc_i) should be near zero   print(round(Z_i_res %*% t(A_parc_i), 10)) } #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 # Sparse example Z_sp <- Matrix::rsparsematrix(3, 5, 0.3) A_sp <- Matrix::rsparsematrix(2, 5, 0.3) residualize_matrix_on_subspace(Z_sp, A_sp) #> Error in residualize_matrix_on_subspace(Z_sp, A_sp): matrix_to_residualize must be a numeric matrix or Matrix object."},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_dispersion_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Riemannian Dispersion of SPD Matrices on the Manifold — riemannian_dispersion_spd","title":"Compute Riemannian Dispersion of SPD Matrices on the Manifold — riemannian_dispersion_spd","text":"Calculates dispersion set SPD matrices around Fréchet mean using Riemannian (Log-Euclidean default) distance.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_dispersion_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Riemannian Dispersion of SPD Matrices on the Manifold — riemannian_dispersion_spd","text":"","code":"riemannian_dispersion_spd(object, ...)  # S3 method for class 'hatsa_projector' riemannian_dispersion_spd(   object,   type = \"cov_coeffs\",   subject_data_list = NULL,   use_geometric_median = FALSE,   k_conn_params = NULL,   spd_regularize_epsilon = 1e-06,   verbose = FALSE,   ... )  # S3 method for class 'list' riemannian_dispersion_spd(   object,   use_geometric_median = FALSE,   spd_regularize_epsilon = 1e-06,   verbose = FALSE,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_dispersion_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Riemannian Dispersion of SPD Matrices on the Manifold — riemannian_dispersion_spd","text":"object `hatsa_projector` `task_hatsa_projector` object. ... Additional arguments passed `frechet_mean_spd`, `riemannian_distance_spd` `get_spd_representations`. type Character string, either `\"cov_coeffs\"` (default) others like `\"fc_conn\"`, `\"fc_task\"` (relying RGEOM-003 `get_spd_representations`). Specifies matrices compute dispersion . subject_data_list Optional, may needed `get_spd_representations`. use_geometric_median Logical, TRUE, attempts use AIRM Fréchet mean (via `shapes::mediancov` available, iterative Log-Euclidean ). FALSE (default), uses iterative Log-Euclidean Fréchet mean. k_conn_params Parameters connectivity type involves FC. spd_regularize_epsilon Epsilon regularizing SPD matrices. verbose Logical, controls verbose output calculations.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_dispersion_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Riemannian Dispersion of SPD Matrices on the Manifold — riemannian_dispersion_spd","text":"list containing: `mean_spd_matrix`, `distances_to_mean` (named vector),   `num_valid_subjects`, `original_num_subjects`, `mean_dispersion`, `median_dispersion`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_matrix_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Pairwise Riemannian Distances Between Subject SPD Representations — riemannian_distance_matrix_spd","title":"Compute Pairwise Riemannian Distances Between Subject SPD Representations — riemannian_distance_matrix_spd","text":"Calculates matrix Riemannian distances (Log-Euclidean metric) subjects, based specified SPD matrix representations derived HATSA object (e.g., covariance aligned coefficients various FC matrices).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_matrix_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Pairwise Riemannian Distances Between Subject SPD Representations — riemannian_distance_matrix_spd","text":"","code":"riemannian_distance_matrix_spd(object, ...)  # S3 method for class 'hatsa_projector' riemannian_distance_matrix_spd(   object,   type = \"cov_coeffs\",   subject_data_list = NULL,   spd_regularize_epsilon = 1e-06,   k_conn_params = NULL,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_matrix_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Pairwise Riemannian Distances Between Subject SPD Representations — riemannian_distance_matrix_spd","text":"object `hatsa_projector` `task_hatsa_projector` object, directly list SPD matrices. ... Additional arguments passed `riemannian_distance_spd` `get_spd_representations` used. type Character string indicating type SPD representation use. Commonly `\"cov_coeffs\"` (default) `k x k` covariance aligned spectral coefficients. types (e.g., `\"fc_conn\"`, `\"fc_task\"`) rely `get_spd_representations` (RGEOM-003) provide SPD matrices. subject_data_list Optional. list subject time-series matrices (T_i x V_p). May needed `get_spd_representations` certain `type` values. spd_regularize_epsilon Epsilon regularizing SPD matrices. k_conn_params Parameters connectivity calculation type involves FC, passed `get_spd_representations`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_matrix_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Pairwise Riemannian Distances Between Subject SPD Representations — riemannian_distance_matrix_spd","text":"symmetric `N_subjects x N_subjects` matrix pairwise Riemannian distances.   Diagonal zero. `NA` distance computed.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","title":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","text":"Calculates Riemannian distance two symmetric positive-definite (SPD) matrices S1 S2, using Log-Euclidean metric described Mitteroecker & Bookstein (2008) Arsigny et al. (2006). `d(S1, S2) = ||logm(S1) - logm(S2)||_F` , M&B formulation, effectively `sqrt(sum(log(lambda_j(S2^-1 S1))^2))`. function core component RGEOM-001.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","text":"","code":"riemannian_distance_spd(   S1,   S2,   regularize_epsilon = 1e-06,   eigenvalue_floor = 1e-09 )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","text":"S1 numeric, symmetric matrix (p x p). S2 numeric, symmetric matrix (p x p). regularize_epsilon small positive value used regularization ensure matrices SPD inversion eigenvalue computation. Default 1e-6. eigenvalue_floor small positive value threshold relative eigenvalues taking logarithm, preventing issues `log(0)`. Default 1e-9.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","text":"Riemannian distance (scalar). Returns `NA` computation fails.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/riemannian_distance_spd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Riemannian Distance Between SPD Matrices (Log-Euclidean Metric) — riemannian_distance_spd","text":"","code":"S1 <- matrix(c(2.3, -0.3, -0.3, 3.6), 2, 2) S2 <- matrix(c(3.7, 1.9, 1.9, 2.8), 2, 2) # riemannian_distance_spd(S1, S2) # Expected: ~1.24156 (Need to import MASS for ginv)  # Identical matrices # riemannian_distance_spd(S1, S1) # Expected: 0"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_cmdscale_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Run `cmdscale` Safely — run_cmdscale_safe","title":"Run `cmdscale` Safely — run_cmdscale_safe","text":"Performs classical MDS error handling.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_cmdscale_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run `cmdscale` Safely — run_cmdscale_safe","text":"","code":"run_cmdscale_safe(dist_matrix, k_mds = 2, add = TRUE)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_cmdscale_safe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run `cmdscale` Safely — run_cmdscale_safe","text":"dist_matrix Symmetric distance matrix. k_mds Number dimensions return. add Logical `add` argument `stats::cmdscale`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_cmdscale_safe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run `cmdscale` Safely — run_cmdscale_safe","text":"Output `stats::cmdscale` `NULL` failure.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_geo_hatsa_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Geometric Harmonized Tensors SVD Alignment (Geo-HATSA) Core Algorithm — run_geo_hatsa_core","title":"Run Geometric Harmonized Tensors SVD Alignment (Geo-HATSA) Core Algorithm — run_geo_hatsa_core","text":"function implements variant HATSA core algorithm Generalized Procrustes Analysis (GPA) step refining rotations group anchor template uses geometric approach (k) via `perform_geometric_gpa_refinement`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_geo_hatsa_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Geometric Harmonized Tensors SVD Alignment (Geo-HATSA) Core Algorithm — run_geo_hatsa_core","text":"","code":"run_geo_hatsa_core(   subject_data_list,   anchor_indices,   spectral_rank_k,   k_conn_pos = 10,   k_conn_neg = 10,   n_refine = 10,   V_p = NULL,   use_dtw = FALSE,   graph_mode = \"anchor_block\",   schur_eps = 0.01,   eigengap_tol = 1e-09,   rotation_mode = \"svd\",   verbose = TRUE,   frechet_mean_options = list(),   gpa_tol = 1e-07 )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_geo_hatsa_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Geometric Harmonized Tensors SVD Alignment (Geo-HATSA) Core Algorithm — run_geo_hatsa_core","text":"subject_data_list list subject-level parcel time-series matrices. element numeric matrix (T_i time points x V_p parcels). anchor_indices numeric vector indices anchor parcels (1-based, referring columns matrices `subject_data_list`). spectral_rank_k Integer, number spectral components (k) retain. k_conn_pos Integer, number positive degree neighbors k-NN graph construction. k_conn_neg Integer, number negative degree neighbors (applicable, often pos). n_refine Integer, number GPA refinement iterations. V_p Integer, number parcels (vertices per subject). NULL, inferred. use_dtw Logical, whether use Dynamic Time Warping FC graph (passed `compute_subject_connectivity_graph_sparse`). Default FALSE. graph_mode Character string, specifies graph construction method. Options include `\"anchor_block\"` (default), `\"schur\"` (Schur complement), `\"full\"` (standard kNN graph). Passed `compute_subject_connectivity_graph_sparse`. schur_eps Numeric, epsilon Schur complement graph construction `graph_mode = \"schur\"`. Default: 0.01. eigengap_tol Numeric, tolerance checking eigengap spectral sketch computation. `lambda_k - lambda_k+1 < eigengap_tol`, warning issued subject. Default: 1e-9. rotation_mode Character string, passed `perform_geometric_gpa_refinement`. One `\"svd\"` (default) `\"riemannian\"`. See function details. verbose Logical, TRUE, prints progress messages. Default TRUE. frechet_mean_options list options pass `hatsa::frechet_mean_so_k` within `perform_geometric_gpa_refinement`. Default: `list()`. gpa_tol Numeric, tolerance convergence `perform_geometric_gpa_refinement`. Default: 1e-7.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_geo_hatsa_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Geometric Harmonized Tensors SVD Alignment (Geo-HATSA) Core Algorithm — run_geo_hatsa_core","text":"list containing core Geo-HATSA results QC metrics: U_aligned_list: List subject-specific aligned sketch matrices (V_p x k). R_final_list: List subject-specific rotation matrices (k x k). U_original_list: List subject-specific original sketch matrices (V_p x k). Lambda_original_list: List subject-specific original eigenvalues (length k). Lambda_original_gaps_list: List subject-specific eigengap ratios. T_anchor_final: final group anchor template matrix (N_anchors x k). R_bar_final: final Fréchet mean rotation matrices Geo-GPA. qc_metrics: data frame per-subject QC flags (laplacian_computed_ok,           sketch_computed_ok, eigengap_sufficient). list intended used input `hatsa_projector` constructor,   though `R_bar_final` additional output specific Geo-HATSA.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Run the Core HATSA Algorithm — run_hatsa_core","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"Implements Core HATSA algorithm align functional connectivity patterns across subjects. version uses sparse matrices graph representations, efficient eigendecomposition via `PRIMME`, incorporates robustness improvements based detailed audits.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"","code":"run_hatsa_core(   subject_data_list,   anchor_indices,   spectral_rank_k,   k_conn_pos,   k_conn_neg,   n_refine,   use_dtw = FALSE,   n_cores = 1L )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"subject_data_list list dense numeric matrices. matrix `X_i` corresponds subject, dimensions `T_i` (time points) x `V_p` (parcels). anchor_indices numeric vector 1-based indices selected anchor parcels. Duplicate indices removed. spectral_rank_k integer specifying dimensionality (`k`) low-dimensional spectral sketch. Must non-negative. `k=0` yields empty sketches. k_conn_pos integer. graph sparsification, number strongest positive connections retain per parcel. k_conn_neg integer. graph sparsification, number strongest negative connections retain per parcel. n_refine integer, number GPA refinement iterations. use_dtw Logical, defaults `FALSE`. `TRUE` (yet fully implemented), Dynamic Time Warping considered graph construction similarity. n_cores Integer number CPU cores use. `> 1` platform supports forking (.e., non-Windows), per-subject computations parallelized via parallel::mclapply. Defaults 1 (sequential).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"`hatsa_projector` object. S3 object inherits   `multiblock_biprojector` (`multivarious` package) contains   results HATSA analysis. Key components include: v: mean aligned sketch (group-level template, V_p x k matrix). s: Stacked aligned sketches subjects ((N*V_p) x k matrix). sdev: Component standard deviations (vector length k, currently defaults 1s). preproc: Preprocessing object (currently `prep(pass())`). block_indices: List defining subject blocks `s` matrix. R_final_list: List subject-specific rotation matrices (k x k). U_original_list: List subject-specific original (unaligned) sketch matrices (V_p x k). Lambda_original_list: List subject-specific original eigenvalues (vector length k) parcel-level decomposition. Essential Nyström voxel projection. T_anchor_final: final group anchor template used alignment (V_a x k matrix, V_a number anchors). parameters: List input parameters used HATSA run (e.g., `k`, `V_p`, `N_subjects`, anchor details, sparsification parameters). method: Character string, \"hatsa_core\". U_aligned_list: (Note: used compute `v` `s`, direct aligned sketches per subject also stored `project_block` needs direct inspection, typically `object$s` reshaped per block) object can used S3 methods like `print`, `summary`, `coef`,   `scores`, `predict` (new parcel data), `project_voxels` (new   voxel data).","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"Expert R Developer (GPT)","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/run_hatsa_core.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run the Core HATSA Algorithm — run_hatsa_core","text":"","code":"# Generate example data set.seed(123) N_subjects <- 3 # Small N for quick example V_p_parcels <- 25 T_times_avg <- 50  # Create a list of matrices (time x parcels) subject_data <- lapply(1:N_subjects, function(i) {   T_i <- T_times_avg + sample(-5:5, 1)   matrix(stats::rnorm(T_i * V_p_parcels), nrow = T_i, ncol = V_p_parcels) })  # Assign parcel names (optional but good practice) parcel_names_vec <- paste0(\"Parcel_\", 1:V_p_parcels) subject_data <- lapply(subject_data, function(mat) {   colnames(mat) <- parcel_names_vec   mat })  # Define HATSA parameters # Ensure number of anchors >= k for stable Procrustes anchor_idx <- sample(1:V_p_parcels, 7) k_spectral <- 5 # k=5, num_anchors=7 is valid k_pos <- 4 k_neg <- 2 n_iter_refine <- 2  # Run Core HATSA (requires Matrix and PRIMME packages) hatsa_results <- NULL if (requireNamespace(\"Matrix\", quietly = TRUE) &&     requireNamespace(\"PRIMME\", quietly = TRUE)) {   hatsa_results <- tryCatch(     run_hatsa_core(       subject_data_list = subject_data,       anchor_indices = anchor_idx,       spectral_rank_k = k_spectral,       k_conn_pos = k_pos,       k_conn_neg = k_neg,       n_refine = n_iter_refine     ),     error = function(e) {       message(\"Example run failed: \", e$message)       NULL     }   )    # Inspect the results object   if (!is.null(hatsa_results)) {     print(hatsa_results)     summary_info <- summary(hatsa_results)     print(summary_info)      # Get coefficients (mean aligned sketch)     group_template <- coef(hatsa_results)     # print(dim(group_template)) # Should be V_p x k      # Get stacked scores (aligned sketches for all subjects)     all_scores <- scores(hatsa_results)     # print(dim(all_scores)) # Should be (N*V_p) x k      # Get block indices to map scores to subjects     indices <- block_indices(hatsa_results)     # subject1_scores <- all_scores[indices[[1]], ]     # print(dim(subject1_scores)) # Should be V_p x k   } } else {   if (interactive()) message(\"Matrix and PRIMME packages needed for this example.\") } #> HATSA Projector Object #> ---------------------- #> Method:  hatsa_core  #> Number of Subjects (N):  3  #> Number of Parcels (V_p):  25  #> Number of Components (k):  5  #>  #> Key components: #>   Mean Aligned Sketch (v): dimensions [ 25 x 5 ] #>   Stacked Aligned Sketches (s): dimensions [ 75 x 5 ] #>   Component Standard Deviations (sdev): length [ 5 ] #>                           Length Class         Mode      #> v                         125    -none-        numeric   #> s                         375    -none-        numeric   #> sdev                        5    -none-        numeric   #> preproc                     4    pre_processor list      #> block_indices               3    -none-        list      #> R_final_list                3    -none-        list      #> U_original_list             3    -none-        list      #> Lambda_original_list        3    -none-        list      #> Lambda_original_gaps_list   3    -none-        list      #> T_anchor_final             35    -none-        numeric   #> parameters                 10    -none-        list      #> method                      1    -none-        character #> ._cache                     1    -none-        list      #> Error in scores(hatsa_results): could not find function \"scores\""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_so_logm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast Fr Mean on SO(k) — safe_so_logm","title":"Fast Fr Mean on SO(k) — safe_so_logm","text":"Computes approximate Fr mean list rotation matrices using chordal (SVD) mean followed optional single Karcher refinement step. refinement converge, falls back full Karcher mean implementation.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_so_logm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast Fr Mean on SO(k) — safe_so_logm","text":"","code":"safe_so_logm(R, tol = 1e-07)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_so_logm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast Fr Mean on SO(k) — safe_so_logm","text":"R square matrix expected close rotation matrix. tol Tolerance treating matrix identity. Rlist list k x k rotation matrices. refine Logical; TRUE single Karcher refinement step attempted. Default TRUE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_so_logm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast Fr Mean on SO(k) — safe_so_logm","text":"k x k matrix representing Fr mean. matrix representing logarithm `R` zero matrix failure.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely evaluate an expression with warning on error — safe_wrapper","text":"","code":"safe_wrapper(expr, msg_fmt, default = NULL)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/safe_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely evaluate an expression with warning on error — safe_wrapper","text":"expr Expression evaluate. msg_fmt format string passed `sprintf`. caught error message inserted via ` defaultValue return evaluation fails. Defaults `NULL`. result `expr`, `default` error.   Evaluates `expr` returns result. error occurs, formatted warning issued `default` returned.  internal","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/scores.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract scores (stacked aligned sketches) from a hatsa_projector object — scores.hatsa_projector","title":"Extract scores (stacked aligned sketches) from a hatsa_projector object — scores.hatsa_projector","text":"Extract scores (stacked aligned sketches) hatsa_projector object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/scores.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract scores (stacked aligned sketches) from a hatsa_projector object — scores.hatsa_projector","text":"","code":"# S3 method for class 'hatsa_projector' scores(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/scores.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract scores (stacked aligned sketches) from a hatsa_projector object — scores.hatsa_projector","text":"x hatsa_projector object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/scores.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract scores (stacked aligned sketches) from a hatsa_projector object — scores.hatsa_projector","text":"stacked aligned sketches matrix (s).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/sdev.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract component standard deviations from a hatsa_projector object — sdev.hatsa_projector","title":"Extract component standard deviations from a hatsa_projector object — sdev.hatsa_projector","text":"Extract component standard deviations hatsa_projector object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/sdev.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract component standard deviations from a hatsa_projector object — sdev.hatsa_projector","text":"","code":"sdev.hatsa_projector(x, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/sdev.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract component standard deviations from a hatsa_projector object — sdev.hatsa_projector","text":"x hatsa_projector object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/sdev.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract component standard deviations from a hatsa_projector object — sdev.hatsa_projector","text":"vector component standard deviations (sdev).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic Anchor Selection Helper — select_anchors_auto","title":"Automatic Anchor Selection Helper — select_anchors_auto","text":"Automatic Anchor Selection Helper","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic Anchor Selection Helper — select_anchors_auto","text":"","code":"select_anchors_auto(data, k, config)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":null,"dir":"Reference","previous_headings":"","what":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"Selects set anchor parcels optimizing criterion balances stability mean anchor representation (via condition number) dispersion subject-specific covariance matrices derived anchors SPD manifold.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"","code":"select_anchors_mra(   U_original_list_pilot,   spectral_rank_k,   m_target,   total_parcels = NULL,   max_kappa = 100,   weight_inv_kappa = 1,   weight_dispersion = 1,   initial_selection = integer(0),   candidate_pool = NULL,   parcel_quality_info = NULL,   riemannian_dispersion_options = list(),   min_anchors_for_metrics = NULL,   verbose = TRUE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"U_original_list_pilot list original (unaligned) sketch matrices (V_p x k) set pilot subjects. used evaluate candidate anchors. spectral_rank_k Integer, spectral rank `k` used generate `U_original_list_pilot`. m_target Integer, desired number anchors select. total_parcels Integer, total number parcels (V_p) available selection. NULL, inferred `U_original_list_pilot`. max_kappa Numeric, maximum allowable condition number mean anchor matrix. Candidates leading kappa penalized excluded. Default: 100. weight_inv_kappa Numeric, weight inverse condition number term score. Higher values prioritize lower condition numbers (stable mean). Default: 1.0. weight_dispersion Numeric, weight negative dispersion term score. Higher values prioritize lower dispersion. Default: 1.0. initial_selection Optional. vector pre-selected anchor indices (1-based). algorithm try add `m_target - length(initial_selection)` new anchors. candidate_pool Optional. vector parcel indices (1-based) select new anchors. NULL, non-initially-selected parcels candidates. parcel_quality_info Optional. Data frame list providing parcel quality network information. Currently unused core MRA logic reserved future extensions (e.g., pre-filtering candidates). riemannian_dispersion_options list options pass `hatsa::riemannian_dispersion_spd` (e.g., `spd_metric`, `use_geometric_median`). min_anchors_for_metrics Integer. Minimum number selected anchors required kappa dispersion metrics considered stable enough compute. Default `spectral_rank_k`. verbose Logical. TRUE, print progress messages. Default: TRUE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"vector selected anchor indices (1-based), sorted.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":"methodological-details","dir":"Reference","previous_headings":"","what":"Methodological Details","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"MRA-Select greedily optimizes composite score balancing condition number mean anchor matrix Riemannian dispersion subject covariance matrices SPD manifold. Candidate anchors maximize score iteratively added m_target anchors selected.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manifold-Regularized Anchor Selection (MRA-Select) — select_anchors_mra","text":"","code":"# Conceptual example (requires U_original_list_pilot from actual or synthetic data) # N_pilot <- 5 # V_p_total <- 50 # k_rank <- 10 # U_pilot_list <- replicate(N_pilot, #                           matrix(rnorm(V_p_total * k_rank), V_p_total, k_rank), #                           simplify = FALSE) # selected_anchors_mra <- select_anchors_mra( #   U_original_list_pilot = U_pilot_list, #   spectral_rank_k = k_rank, #   m_target = 15, #   total_parcels = V_p_total, #   verbose = TRUE # ) # print(selected_anchors_mra)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra_quality.html","id":null,"dir":"Reference","previous_headings":"","what":"Enhanced MRA Selection with Quality Filtering — select_anchors_mra_quality","title":"Enhanced MRA Selection with Quality Filtering — select_anchors_mra_quality","text":"Wrapper around select_anchors_mra uses parcel quality information pre-filter candidates weight selection.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra_quality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enhanced MRA Selection with Quality Filtering — select_anchors_mra_quality","text":"","code":"select_anchors_mra_quality(   U_original_list_pilot,   spectral_rank_k,   m_target,   parcel_quality_info = NULL,   quality_threshold = 0.3,   quality_weight = 0.2,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra_quality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enhanced MRA Selection with Quality Filtering — select_anchors_mra_quality","text":"U_original_list_pilot Pilot subject sketch matrices spectral_rank_k Number spectral components m_target Target number anchors parcel_quality_info Data frame parcel quality information quality_threshold Minimum quality score candidate parcels (0-1) quality_weight Weight quality selection (0-1) ... Additional arguments passed select_anchors_mra","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_mra_quality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enhanced MRA Selection with Quality Filtering — select_anchors_mra_quality","text":"Selected anchor indices","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_network_balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Network-Informed Anchor Selection — select_anchors_network_balanced","title":"Network-Informed Anchor Selection — select_anchors_network_balanced","text":"Select anchors represent different functional networks brain regions.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_network_balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Network-Informed Anchor Selection — select_anchors_network_balanced","text":"","code":"select_anchors_network_balanced(   U_original_list_pilot,   spectral_rank_k,   m_target,   network_labels,   anchors_per_network = 2,   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_network_balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Network-Informed Anchor Selection — select_anchors_network_balanced","text":"U_original_list_pilot Pilot subject sketch matrices spectral_rank_k Number spectral components m_target Target number anchors network_labels Vector network labels parcel anchors_per_network Minimum anchors per network ... Additional arguments select_anchors_mra","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_anchors_network_balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Network-Informed Anchor Selection — select_anchors_network_balanced","text":"Selected anchor indices","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_task_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic Task Method Selection — select_task_method","title":"Automatic Task Method Selection — select_task_method","text":"Automatic Task Method Selection","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/select_task_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic Task Method Selection — select_task_method","text":"","code":"select_task_method(data, task_data)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_gev_laplacian_primme.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Generalized Eigenvalue Problem for Laplacians using PRIMME — solve_gev_laplacian_primme","title":"Solve Generalized Eigenvalue Problem for Laplacians using PRIMME — solve_gev_laplacian_primme","text":"Solves generalized eigenvalue problem `v = λ B v` B typically sparse graph Laplacians (e.g., `L_task` `L_conn`). finds eigenvectors corresponding smallest magnitude eigenvalues (`λ`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_gev_laplacian_primme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Generalized Eigenvalue Problem for Laplacians using PRIMME — solve_gev_laplacian_primme","text":"","code":"solve_gev_laplacian_primme(   A,   B,   k_request,   lambda_max_thresh = 0.8,   epsilon_reg_B = 1e-06,   tol = 1e-08,   primme_which = \"SA\",   ... )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_gev_laplacian_primme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Generalized Eigenvalue Problem for Laplacians using PRIMME — solve_gev_laplacian_primme","text":"sparse, symmetric matrix left side (e.g., `L_task`, `dgCMatrix`). B sparse, symmetric, positive semi-definite matrix right side (e.g., `L_conn`, `dgCMatrix`). regularized. k_request Integer, number eigenvalues/vectors compute (`NEig`). lambda_max_thresh Numeric, maximum absolute eigenvalue (`|λ|`) retain. Eigenpairs `abs(values) >= lambda_max_thresh` discarded. epsilon_reg_B Numeric, small value add diagonal B regularization (`B_reg = B + epsilon_reg_B * `). Helps ensure B positive definite solver. Default 1e-6. tol Numeric, tolerance eigenvalue decomposition convergence. Default 1e-8 (PRIMME's default 1e-6, using slightly tighter). primme_which Character string passed `PRIMME::eigs_sym` control eigenvalues computed. Defaults \"SA\" (smallest algebraic) targets smallest eigenvalues. ... Additional arguments passed `PRIMME::eigs_sym`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_gev_laplacian_primme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Generalized Eigenvalue Problem for Laplacians using PRIMME — solve_gev_laplacian_primme","text":"list containing: vectors: dense matrix (`V_p x k_actual`) filtered eigenvectors. values: numeric vector corresponding filtered eigenvalues. n_converged: number eigenpairs PRIMME reports converged. n_filtered: number eigenpairs remaining filtering. primme_stats: stats list returned PRIMME. Throws error computation fails. Note: Stability   filtering based split-half reliability (`r_split`) needs applied   separately. Eigenvectors B-orthogonal.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Orthogonal Procrustes Problem for `R_i` in SO(k) — solve_procrustes_rotation","title":"Solve Orthogonal Procrustes Problem for `R_i` in SO(k) — solve_procrustes_rotation","text":"Finds `R_i (k)` best aligns `A_orig_subj_anchor` `T_anchor_group`. standard unweighted version.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Orthogonal Procrustes Problem for `R_i` in SO(k) — solve_procrustes_rotation","text":"","code":"solve_procrustes_rotation(A_orig_subj_anchor, T_anchor_group)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Orthogonal Procrustes Problem for `R_i` in SO(k) — solve_procrustes_rotation","text":"A_orig_subj_anchor Numeric matrix (`m x k`), subject's anchor sketch. T_anchor_group Numeric matrix (`m x k`), group anchor template.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Orthogonal Procrustes Problem for `R_i` in SO(k) — solve_procrustes_rotation","text":"Orthogonal rotation matrix `R_i` (`k x k`) `det(R_i) = 1`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"Finds optimal rotation matrix `R` aligns source matrix `A_source`   target matrix `T_target`, minimizing `|| Omega (A_source R - T_target) ||_F^2`,   `Omega` diagonal weighting matrix.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"","code":"solve_procrustes_rotation_weighted(   A_source,   T_target,   m_parcel_rows,   m_task_rows,   omega_mode = \"fixed\",   fixed_omega_weights = NULL,   reliability_scores = NULL,   scale_omega_trace = TRUE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"A_source numeric source matrix (e.g., augmented anchors one subject), dimensions `N x k` (N = total anchors, k = dimensions). T_target numeric target matrix (e.g., augmented template), dimensions `N x k`. m_parcel_rows Integer, number rows `A_source` (`T_target`) corresponding parcel anchors. Assumed first `m_parcel_rows`. m_task_rows Integer, number rows `A_source` (`T_target`) corresponding task condition anchors. Assumed parcel rows. omega_mode Character string, mode determining weights: `\"fixed\"` (default) `\"adaptive\"`. fixed_omega_weights List, used `omega_mode == \"fixed\"`. E.g., `list(parcel = 1.0, condition = 0.5)`. `NULL`, defaults . reliability_scores Numeric vector length `m_task_rows`, containing reliability scores (e.g., R^2_p) task condition. Required used `omega_mode == \"adaptive\"`. scale_omega_trace Logical, whether rescale diagonal `Omega` matrix `sum(diag(Omega)) == N`. Default `TRUE`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"`k x k` rotation matrix `R`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"Internally computes weighted cross-product using   `crossprod(A_source, T_target * omega_diag_vector)` avoid creating   separate weighted matrices `A_source` `T_target`. spectral dimension `k` 1, SVD-based determinant correction unnecessary. case rotation simply sign scalar cross-product `M`, .e. `R <- matrix(sign(M), 1, 1)`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/solve_procrustes_rotation_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve Weighted Procrustes Rotation Problem — solve_procrustes_rotation_weighted","text":"","code":"N_parcels <- 5 N_tasks <- 3 N_total <- N_parcels + N_tasks k_dims <- 4 A <- matrix(rnorm(N_total * k_dims), N_total, k_dims) T_true <- matrix(rnorm(N_total * k_dims), N_total, k_dims) R_true <- svd(matrix(rnorm(k_dims*k_dims),k_dims,k_dims))$u %*%            diag(sample(c(1,1,1,-1),k_dims,replace=TRUE)) %*%            svd(matrix(rnorm(k_dims*k_dims),k_dims,k_dims))$v A_rotated_perfect <- T_true %*% t(R_true) # A_rotated_perfect R_true should be T_true  # Fixed weights (default) R_fixed <- solve_procrustes_rotation_weighted(A_rotated_perfect, T_true,                                                N_parcels, N_tasks) # print(all.equal(T_true %*% t(R_fixed), A_rotated_perfect)) # Check alignment print(sum((A_rotated_perfect %*% R_fixed - T_true)^2)) # Should be small #> [1] 6.746785e-30  # Adaptive weights (example with dummy reliabilities) set.seed(123) rel_scores <- runif(N_tasks, -0.2, 0.8) R_adaptive <- solve_procrustes_rotation_weighted(A_rotated_perfect, T_true,                                                   N_parcels, N_tasks,                                                   omega_mode = \"adaptive\",                                                   reliability_scores = rel_scores) print(sum((A_rotated_perfect %*% R_adaptive - T_true)^2)) # Should be small #> [1] 6.642063e-30  # No task rows R_no_task <- solve_procrustes_rotation_weighted(A[1:N_parcels,], T_true[1:N_parcels,],                                                 N_parcels, 0)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for hatsa_projector objects — summary.hatsa_projector","title":"Summary method for hatsa_projector objects — summary.hatsa_projector","text":"Provides detailed summary hatsa_projector object, including mean anchor alignment error original subjects.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for hatsa_projector objects — summary.hatsa_projector","text":"","code":"summary.hatsa_projector(   object,   ...,   compute_riemannian_dispersion = FALSE,   riemannian_dispersion_type = \"cov_coeffs\",   riemannian_dispersion_options = list(),   recompute_R_bar = FALSE )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for hatsa_projector objects — summary.hatsa_projector","text":"object hatsa_projector object. ... Additional arguments (unused). compute_riemannian_dispersion Logical, TRUE, computes includes Riemannian dispersion metrics SPD representations (default: FALSE). riemannian_dispersion_type Character string, type SPD representation dispersion (e.g., \"cov_coeffs\"). Passed `riemannian_dispersion_spd`. riemannian_dispersion_options list additional arguments passed `riemannian_dispersion_spd` (e.g., `use_geometric_median`, `spd_regularize_epsilon`, `verbose`). recompute_R_bar Logical; TRUE Fr mean rotations recomputed even cached value present. Default FALSE.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for hatsa_projector objects — summary.hatsa_projector","text":"list object class summary.hatsa_projector containing   summary statistics.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.task_hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for task_hatsa_projector objects — summary.task_hatsa_projector","title":"Summary method for task_hatsa_projector objects — summary.task_hatsa_projector","text":"Summary method task_hatsa_projector objects","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.task_hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for task_hatsa_projector objects — summary.task_hatsa_projector","text":"","code":"summary.task_hatsa_projector(object, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.task_hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for task_hatsa_projector objects — summary.task_hatsa_projector","text":"object `task_hatsa_projector` object. ... Additional arguments (unused).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary.task_hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for task_hatsa_projector objects — summary.task_hatsa_projector","text":"list object class `summary.task_hatsa_projector` containing summary statistics.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary_enhanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Enhanced Summary for HATSA with All Quality Metrics — summary_enhanced","title":"Enhanced Summary for HATSA with All Quality Metrics — summary_enhanced","text":"Provides comprehensive summary including HMET metrics.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary_enhanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enhanced Summary for HATSA with All Quality Metrics — summary_enhanced","text":"","code":"summary_enhanced(object, include_condition_numbers = TRUE, ...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary_enhanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enhanced Summary for HATSA with All Quality Metrics — summary_enhanced","text":"object hatsa_projector object include_condition_numbers Whether compute condition numbers ... Additional arguments","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/summary_enhanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enhanced Summary for HATSA with All Quality Metrics — summary_enhanced","text":"Enhanced summary object","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Hyperalignment via Task-Informed Shared Analysis — task_hatsa","title":"Hyperalignment via Task-Informed Shared Analysis — task_hatsa","text":"user-friendly interface run Task-Informed HATSA (task_hatsa), incorporates task information basis shaping /alignment refinement.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hyperalignment via Task-Informed Shared Analysis — task_hatsa","text":"","code":"task_hatsa(   subject_data_list,   anchor_indices,   spectral_rank_k = 40,   task_data_list = NULL,   task_method = c(\"lambda_blend\", \"gev_patch\", \"core_hatsa\"),   opts = task_hatsa_opts(),   verbose = TRUE,   ... )  run_task_hatsa(...)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hyperalignment via Task-Informed Shared Analysis — task_hatsa","text":"subject_data_list List element numeric matrix (`T_i x V_p`) time-series data one subject. anchor_indices Integer vector, indices canonical anchor parcels (`1` `V_p`). spectral_rank_k Integer, desired dimensionality primary spectral sketch. Default 40. task_data_list List (parallel `subject_data_list`). element provides task-related data subject. Structure depends `task_method` subsequent processing. Default NULL. task_method Character string: `\"lambda_blend\"`, `\"gev_patch\"`, `\"core_hatsa\"`. Default: `\"lambda_blend\"`. opts List advanced options created `task_hatsa_opts()`. verbose Logical. Print progress messages? Default `TRUE`. ... Additional arguments passed `task_hatsa_opts()` provided directly via `opts`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hyperalignment via Task-Informed Shared Analysis — task_hatsa","text":"list representing `task_hatsa_projector` object containing aligned bases,         rotations, parameters, QC metrics, etc.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Advanced Options for Task-Informed HATSA — task_hatsa_opts","title":"Advanced Options for Task-Informed HATSA — task_hatsa_opts","text":"Creates list advanced parameters task_hatsa function.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Advanced Options for Task-Informed HATSA — task_hatsa_opts","text":"","code":"task_hatsa_opts(   lambda_blend_value = 0.15,   k_gev_dims = 10,   row_augmentation = TRUE,   residualize_condition_anchors = FALSE,   omega_weights = NULL,   omega_mode = c(\"fixed\", \"adaptive\"),   reliability_scores_list = NULL,   scale_omega_trace = TRUE,   alpha_laplacian = 0.93,   degree_type_laplacian = c(\"abs\", \"positive\", \"signed\"),   k_conn_pos = 10,   k_conn_neg = 10,   k_conn_task_pos = 10,   k_conn_task_neg = 10,   similarity_method_task = \"pearson\",   W_task_helper_func = NULL,   n_refine = 5,   check_redundancy = TRUE,   redundancy_threshold = 0.45,   residualize_k_conn_proj = 64,   residualize_k_conn_labels = 10,   gev_lambda_max = 0.8,   gev_epsilon_reg = 1e-06,   parcel_names = NULL )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Advanced Options for Task-Informed HATSA — task_hatsa_opts","text":"lambda_blend_value Numeric `lambda` `[0,1]`. Weight `L_task` blend. Default 0.15. k_gev_dims Integer, requested dimension GEV patches. Default 10. Used `task_method == \"gev_patch\"`. row_augmentation Logical. `TRUE`, add projected task features anchor matrices GPA refinement. Requires suitable `task_data_list`. Default `TRUE` suitable data provided. residualize_condition_anchors Logical. `TRUE` `row_augmentation` `TRUE`, residualize projected task anchors parcel anchors. Default `FALSE`. omega_weights List specifying fixed weights weighted Procrustes (e.g., `list(parcel = 1.0, condition = 0.5)`). Used `row_augmentation=TRUE` `omega_mode == \"fixed\"`. Defaults handled `solve_procrustes_rotation_weighted`. omega_mode Character string: `\"fixed\"` `\"adaptive\"`. Controls weighting GPA. Default `\"fixed\"`. reliability_scores_list List (parallel `subject_data_list`), element numeric vector reliability scores (e.g., R^2) task data (length `C`). Used `omega_mode == \"adaptive\"`. scale_omega_trace Logical. Whether rescale weights weighted GPA trace equals total anchors. Default `TRUE`. alpha_laplacian Numeric, laziness parameter graph Laplacians (`L = - alpha D^-1 W`). Default 0.93. degree_type_laplacian Character string (`\"abs\"`, `\"positive\"`, `\"signed\"`). Type degree calculation Laplacian. Default `\"abs\"`. k_conn_pos Integer >= 0. k-NN sparsification positive edges `W_conn`. k_conn_neg Integer >= 0. k-NN sparsification negative edges `W_conn`. k_conn_task_pos Integer >= 0. k-NN sparsification positive edges `W_task`. k_conn_task_neg Integer >= 0. k-NN sparsification negative edges `W_task`. similarity_method_task Character string function. Method compute similarity `W_task` (e.g., \"pearson\", \"spearman\"). Default \"pearson\". W_task_helper_func Function. specific function compute `W_task` (e.g., `compute_W_task_from_activations`, `compute_W_task_from_encoding`). `NULL`, attempts infer based `task_data_list` structure (currently assumes activations `C x Vp`). Default `NULL`. n_refine Integer >= 0. Number GPA refinement iterations. check_redundancy Logical. `TRUE`, check correlation `W_conn` `W_task`. Default `TRUE`. redundancy_threshold Numeric. Spearman rho threshold triggering `W_task` residualization. Default 0.45. residualize_k_conn_proj Integer. Number `L_conn` eigenvectors project `W_task` . Default 64. residualize_k_conn_labels Integer. k-NN value re-sparsifying `W_task_res` residualization. Default 10. gev_lambda_max Numeric. Max GEV eigenvalue `lambda` retain patches. Default 0.8. gev_epsilon_reg Numeric. Small regularization `L_conn` GEV. Default 1e-6. parcel_names Optional character vector parcel names. `NULL`, names like \"P1\", \"P2\"... generated.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Advanced Options for Task-Informed HATSA — task_hatsa_opts","text":"list options pass task_hatsa function.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":null,"dir":"Reference","previous_headings":"","what":"Task-HATSA Projector Object — task_hatsa_projector","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"S3 object class `task_hatsa_projector` stores results Task-Informed Harmonized Tensors SVD Alignment (task_hatsa) analysis. object inherits `hatsa_projector`. Creates `task_hatsa_projector` object. takes full results list main `task_hatsa` computation (prepared `construct_output` helper) structures S3 object, inheriting `hatsa_projector`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"","code":"task_hatsa_projector(task_hatsa_results)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"task_hatsa_results list containing outputs `task_hatsa` run. list expected specific named elements corresponding various stages parameters analysis (e.g., `parameters`, `R_final_list`, `U_original_list`, `Lambda_original_list`, `T_anchor_final`, `U_aligned_list`, `qc_metrics`, `anchor_augmentation_info`, `gev_patch_data`).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"`task_hatsa_projector` object. object class `c(\"task_hatsa_projector\", \"hatsa_projector\", \"multiblock_biprojector\", \"projector\", \"list\")`.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"qc_metrics list per subject containing QC metrics like `rho_redundancy` (correlation W_conn W_task_raw) `was_residualized` (boolean flag). anchor_augmentation_info list containing information related anchor augmentation, `m_parcel_rows`, `m_task_rows_effective`, `condition_labels`, `was_residualized` (condition anchors), `omega_mode_used`, `omega_weights_params`, `trace_scaled`. gev_patch_data list containing GEV-specific outputs `task_method == \"gev_patch\"`. Includes `U_patch_list`, `Lambda_patch_list`, `R_patch_list`, `diagnostics`. NULL otherwise.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/hatsa/reference/task_hatsa_projector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Task-HATSA Projector Object — task_hatsa_projector","text":"","code":"# This is a conceptual example, as real data structures are complex. # Assuming hatsa_results and params are populated from run_hatsa_core: # projector_obj <- hatsa_projector( #   hatsa_core_results = list( #     U_aligned_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE), #     R_final_list = replicate(5, diag(10), simplify=FALSE), #     U_original_list = replicate(5, matrix(rnorm(100*10), 100, 10), simplify=FALSE), #     Lambda_original_list = replicate(5, runif(10, 0.1, 1), simplify=FALSE), # example #     Lambda_original_gaps_list = replicate(5, runif(9, 0.05, 0.5), simplify=FALSE), # example #     T_anchor_final = matrix(rnorm(5*10), 5, 10) #   ), #   parameters = list( #     k=10, #     N_subjects=5, #     V_p=100, #     method=\"hatsa_core\" #   ) # ) # class(projector_obj) # names(projector_obj)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_anchors.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Pre-selected Anchors — validate_anchors","title":"Validate Pre-selected Anchors — validate_anchors","text":"Validates set pre-selected anchors new data ensure maintain good performance.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_anchors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Pre-selected Anchors — validate_anchors","text":"","code":"validate_anchors(   data,   anchor_indices,   n_components = 20,   reference_metrics = NULL )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_anchors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Pre-selected Anchors — validate_anchors","text":"data New dataset validate anchor_indices Pre-selected anchor indices n_components Number components (match selection) reference_metrics Optional reference metrics training","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_anchors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Pre-selected Anchors — validate_anchors","text":"Validation report","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_hatsa_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for run_hatsa_core — validate_hatsa_inputs","title":"Validate inputs for run_hatsa_core — validate_hatsa_inputs","text":"Checks validity input parameters main HATSA function. Stops error validation fails.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_hatsa_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for run_hatsa_core — validate_hatsa_inputs","text":"","code":"validate_hatsa_inputs(   subject_data_list,   anchor_indices,   spectral_rank_k,   k_conn_pos,   k_conn_neg,   n_refine,   V_p )"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_hatsa_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for run_hatsa_core — validate_hatsa_inputs","text":"subject_data_list list matrices, matrix `X_i` `T_i x V_p` (time points parcels) subject ``. anchor_indices numeric vector 1-based indices anchor parcels. spectral_rank_k integer, spectral rank `k`. Must `>= 0`. k_conn_pos integer, number positive connections sparsification. k_conn_neg integer, number negative connections sparsification. n_refine integer, number GPA refinement iterations. V_p integer, number parcels (columns `subject_data_list` elements).","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/validate_hatsa_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate inputs for run_hatsa_core — validate_hatsa_inputs","text":"Invisibly returns list containing potentially modified `anchor_indices`   (uniquified) validation passes.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/zscore_nonzero_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Safe Z-scoring of non-zero values in a (potentially sparse) matrix — zscore_nonzero_sparse","title":"Safe Z-scoring of non-zero values in a (potentially sparse) matrix — zscore_nonzero_sparse","text":"Z-scores non-zero elements matrix. standard deviation non-zero values 0 (e.g., non-zero values identical, one non-zero value exists), values set 0. IMPORTANT: symmetric matrices, ensure one triangle (diagonal) stored `x@x` (e.g., `Matrix::forceSymmetric(x, uplo=\"U\")` prior calling) prevent breaking symmetry `x@x` contained duplicates triangles.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/zscore_nonzero_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safe Z-scoring of non-zero values in a (potentially sparse) matrix — zscore_nonzero_sparse","text":"","code":"zscore_nonzero_sparse(x)"},{"path":"https://bbuchsbaum.github.io/hatsa/reference/zscore_nonzero_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safe Z-scoring of non-zero values in a (potentially sparse) matrix — zscore_nonzero_sparse","text":"x numeric matrix (can base R matrix sparse `Matrix` object). sparse, assumed `x@x` holds structurally non-zero values.","code":""},{"path":"https://bbuchsbaum.github.io/hatsa/reference/zscore_nonzero_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safe Z-scoring of non-zero values in a (potentially sparse) matrix — zscore_nonzero_sparse","text":"matrix class dimensions `x`, non-zero   elements z-scored.","code":""}]
